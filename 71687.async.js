"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[71687],{86875:function(t,e,n){function r(){return new Float32Array(3)}function o(t){const e=new Float32Array(3);return e[0]=t[0],e[1]=t[1],e[2]=t[2],e}function i(t,e,n){const r=new Float32Array(3);return r[0]=t,r[1]=e,r[2]=n,r}function u(){return r()}function a(){return i(1,1,1)}function c(){return i(1,0,0)}function s(){return i(0,1,0)}function f(){return i(0,0,1)}n.d(e,{Ue:function(){return r},al:function(){return i},d9:function(){return o}});const l=u(),d=a(),b=c(),g=s(),w=f();Object.freeze(Object.defineProperty({__proto__:null,ONES:d,UNIT_X:b,UNIT_Y:g,UNIT_Z:w,ZEROS:l,clone:o,create:r,fromValues:i,ones:a,unitX:c,unitY:s,unitZ:f,zeros:u},Symbol.toStringTag,{value:"Module"}))},37058:function(t,e,n){n.r(e),n.d(e,{default:function(){return y}});var r=n(3480),o=n(59384),i=n(18156),u=n(21117),a=n(24910),c=n(86875),s=n(45213),f=n(30146),l=n(16786),d=n(78986);class b{transform(t){const e=this._transform(t),n=[e.points.buffer,e.rgb.buffer];null!=e.pointIdFilterMap&&n.push(e.pointIdFilterMap.buffer);for(const t of e.attributes)"buffer"in t.values&&(0,o.eP)(t.values.buffer)&&t.values.buffer!==e.rgb.buffer&&n.push(t.values.buffer);return Promise.resolve({result:e,transferList:n})}_transform(t){const e=(0,l.Ym)(t.schema,t.geometryBuffer);let n=e.length/3,o=null;const i=new Array,u=(0,l.dH)(t.primaryAttributeData,e,n);null!=t.primaryAttributeData&&u&&i.push({attributeInfo:t.primaryAttributeData.attributeInfo,values:u});const a=(0,l.dH)(t.modulationAttributeData,e,n);null!=t.modulationAttributeData&&a&&i.push({attributeInfo:t.modulationAttributeData.attributeInfo,values:a});let c=(0,l.aE)(t.rendererInfo,u,a,n);if(t.filterInfo&&t.filterInfo.length>0&&null!=t.filterAttributesData){const u=t.filterAttributesData.filter(r.pC).map((t=>{const r=(0,l.dH)(t,e,n),o={attributeInfo:t.attributeInfo,values:r};return i.push(o),o}));o=new Uint32Array(n),n=(0,l.hv)(e,c,o,t.filterInfo,u)}for(const r of t.userAttributesData){const t=(0,l.dH)(r,e,n);i.push({attributeInfo:r.attributeInfo,values:t})}3*n<c.length&&(c=new Uint8Array(c.buffer.slice(0,3*n))),function(t,e,n){if(0!==n)for(let r=0;r<e;r++)t[3*r+2]+=n}(e,n,t.elevationOffset);const f=g(e,n,d.Oo.fromData(t.obbData),s.Z.fromJSON(t.inSR),s.Z.fromJSON(t.outSR));return{obbData:t.obbData,points:f,rgb:c,attributes:i,pointIdFilterMap:o}}}function g(t,e,n,r,o){if(!(0,f.projectBuffer)(t,r,0,t,o,0,e))throw new Error("Can't reproject");const u=(0,c.d9)(n.center),s=(0,c.Ue)(),l=(0,c.Ue)(),d=(0,c.d9)(n.halfSize);(0,i.Kx)(w,n.quaternion);const b=new Float32Array(3*e);for(let n=0;n<e;n++){let e=3*n;s[0]=t[e]-u[0],s[1]=t[e+1]-u[1],s[2]=t[e+2]-u[2],(0,a.v)(l,s,w),d[0]=Math.max(d[0],Math.abs(l[0])),d[1]=Math.max(d[1],Math.abs(l[1])),d[2]=Math.max(d[2],Math.abs(l[2])),b[e++]=s[0],b[e++]=s[1],b[e]=s[2]}return n.halfSize=d,b}const w=(0,u.Ue)();function y(){return new b}},68901:function(t,e,n){n.d(e,{Es:function(){return h},W7:function(){return y},I_:function(){return b},Jx:function(){return g},qM:function(){return m}});var r=n(88194),o=n(28947),i=n(96711),u=n(59384);var a=n(78395),c=n(52061);const s=()=>i.Z.getLogger("esri.views.3d.layers.i3s.I3SBinaryReader");function f(t,e,n){let o="",i=0;for(;i<n;){const u=t[e+i];if(u<128)o+=String.fromCharCode(u),i++;else if(u>=192&&u<224){if(i+1>=n)throw new r.Z("utf8-decode-error","UTF-8 Decode failed. Two byte character was truncated.");const a=(31&u)<<6|63&t[e+i+1];o+=String.fromCharCode(a),i+=2}else if(u>=224&&u<240){if(i+2>=n)throw new r.Z("utf8-decode-error","UTF-8 Decode failed. Multi byte character was truncated.");const a=(15&u)<<12|(63&t[e+i+1])<<6|63&t[e+i+2];o+=String.fromCharCode(a),i+=3}else{if(!(u>=240&&u<248))throw new r.Z("utf8-decode-error","UTF-8 Decode failed. Invalid multi byte sequence.");{if(i+3>=n)throw new r.Z("utf8-decode-error","UTF-8 Decode failed. Multi byte character was truncated.");const a=(7&u)<<18|(63&t[e+i+1])<<12|(63&t[e+i+2])<<6|63&t[e+i+3];if(a>=65536){const t=55296+(a-65536>>10),e=56320+(1023&a);o+=String.fromCharCode(t,e)}else o+=String.fromCharCode(a);i+=4}}}return o}function l(t,e){const n={byteOffset:0,byteCount:0,fields:Object.create(null)};let r=0;for(let o=0;o<e.length;o++){const i=e[o],u=i.valueType||i.type,a=v[u];n.fields[i.property]=a(t,r),r+=U[u].BYTES_PER_ELEMENT}return n.byteCount=r,n}function d(t,e,n){const o=[];let i,u,a=0;for(u=0;u<t;u+=1){if(i=e[u],i>0){if(o.push(f(n,a,i-1)),0!==n[a+i-1])throw new r.Z("string-array-error","Invalid string array: missing null termination.")}else o.push(null);a+=i}return o}function b(t,e){return new(0,U[e.valueType])(t,e.byteOffset,e.count*e.valuesPerElement)}function g(t,e){if(!t)return null;const n=t[e];return(0,u.z3)(t)?n===u.EK?null:n:(0,u.Hx)(t)?n===u.aS?null:n:n!=n?null:n}function w(t,e,n){if(e!==t&&s().error(`Invalid ${n} buffer size\n expected: ${t}, actual: ${e})`),e<t)throw new r.Z("buffer-too-small","Binary buffer is too small",{expectedSize:t,actualSize:e})}function y(t,e){const n=l(t,e&&e.header);let r=n.byteCount;const o={isDraco:!1,header:n,byteOffset:n.byteCount,byteCount:0,vertexAttributes:{}},i=n.fields,u=null!=i.vertexCount?i.vertexCount:i.count;for(const t of e.ordering){if(!e.vertexAttributes[t])continue;const n={...e.vertexAttributes[t],byteOffset:r,count:u},i=p[t]||"_"+t;o.vertexAttributes[i]=n,r+=I(n.valueType)*n.valuesPerElement*u}const a=i.faceCount;if(e.faces&&a){o.faces={};for(const t of e.ordering){if(!e.faces[t])continue;const n={...e.faces[t],byteOffset:r,count:a};o.faces[t]=n,r+=I(n.valueType)*n.valuesPerElement*a}}const c=i.featureCount;if(e.featureAttributes&&e.featureAttributeOrder&&c){o.featureAttributes={};for(const t of e.featureAttributeOrder){if(!e.featureAttributes[t])continue;const n={...e.featureAttributes[t],byteOffset:r,count:c};o.featureAttributes[t]=n,r+=("UInt64"===n.valueType?8:I(n.valueType))*n.valuesPerElement*c}}return w(r,t.byteLength,"geometry"),o.byteCount=r-o.byteOffset,o}function h(t,e){return t&&t.compressedAttributes&&"draco"===t.compressedAttributes.encoding?function(t){const e={isDraco:!0,isLegacy:!1,color:!1,normal:!1,uv0:!1,uvRegion:!1,featureIndex:!1};for(const n of t)switch(n){case"position":break;case"normal":e.normal=!0;break;case"uv0":e.uv0=!0;break;case"color":e.color=!0;break;case"uv-region":e.uvRegion=!0;break;case"feature-index":e.featureIndex=!0}return e}(t.compressedAttributes.attributes):t?function(t){return{isDraco:!1,isLegacy:!1,color:null!=t.color,normal:null!=t.normal,uv0:null!=t.uv0,uvRegion:null!=t.uvRegion,featureIndex:null!=t.faceRange&&null!=t.featureId}}(t):function(t){const e={isDraco:!1,isLegacy:!0,color:!1,normal:!1,uv0:!1,uvRegion:!1,featureIndex:!1};for(const n of t.ordering)if(t.vertexAttributes[n])switch(n){case"position":break;case"normal":e.normal=!0;break;case"color":e.color=!0;break;case"uv0":e.uv0=!0;break;case"region":e.uvRegion=!0}return t.featureAttributes&&t.featureAttributeOrder&&(e.featureIndex=!0),e}(e)}const p={position:c.T.POSITION,normal:c.T.NORMAL,color:c.T.COLOR,uv0:c.T.UV0,region:c.T.UVREGION};function m(t,e,n,i=!1){if("lepcc-rgb"===t.encoding)return i?(0,a.IT)(e):function(t){return Array.isArray(t)?t.length<u.c8?t:new Uint8Array(t):t.length<u.c8?Array.from(t):t}((0,a.IT)(e));if("lepcc-intensity"===t.encoding)return i?(0,a.ti)(e):function(t){return Array.isArray(t)?t.length<u.c8?t:new Uint16Array(t):t.length<u.c8?Array.from(t):t}((0,a.ti)(e));if(null!=t.encoding&&""!==t.encoding)throw new r.Z("unknown-attribute-storage-info-encoding","Unknown Attribute Storage Info Encoding");t["attributeByteCounts "]&&!t.attributeByteCounts&&(s().warn("Warning: Trailing space in 'attributeByteCounts '."),t.attributeByteCounts=t["attributeByteCounts "]),"ObjectIds"===t.ordering[0]&&t.hasOwnProperty("objectIds")&&(s().warn("Warning: Case error in objectIds"),t.ordering[0]="objectIds");const c=function(t,e,n){const i=null!=e.header?l(t,e.header):{byteOffset:0,byteCount:0,fields:{count:n}},u={header:i,byteOffset:i.byteCount,byteCount:0,entries:Object.create(null)};let a=i.byteCount;for(let t=0;t<e.ordering.length;t++){const n=e.ordering[t],c=(0,o.d9)(e[n]);if(c.count=i.fields.count??0,"String"===c.valueType){if(c.byteOffset=a,c.byteCount=i.fields[n+"ByteCount"],"UTF-8"!==c.encoding)throw new r.Z("unsupported-encoding","Unsupported String encoding.",{encoding:c.encoding});if(c.timeEncoding&&"ECMA_ISO8601"!==c.timeEncoding)throw new r.Z("unsupported-time-encoding","Unsupported time encoding.",{timeEncoding:c.timeEncoding})}else{if(!A(c.valueType))throw new r.Z("unsupported-value-type","Unsupported binary valueType",{valueType:c.valueType});{const t=I(c.valueType);a+=a%t!=0?t-a%t:0,c.byteOffset=a,c.byteCount=t*c.valuesPerElement*c.count}}a+=c.byteCount??0,u.entries[n]=c}return u.byteCount=a-u.byteOffset,u}(e,t,n);w(c.byteOffset+c.byteCount,e.byteLength,"attribute");const f=c.entries.attributeValues||c.entries.objectIds;if(f){if("String"===f.valueType){const t=c.entries.attributeByteCounts,n=b(e,t),r=function(t,e){return new Uint8Array(t,e.byteOffset,e.byteCount)}(e,f);return f.timeEncoding?function(t,e,n){return d(t,e,n).map((t=>{const e=t?Date.parse(t):null;return null==e||Number.isNaN(e)?null:e}))}(t.count,n,r):d(t.count,n,r)}return i?b(e,f):function(t,e){const n=b(t,e);if(n.length>=u.c8)return n;const r=new Array;return n.forEach(((t,e)=>r.push(g(n,e)))),r}(e,f)}throw new r.Z("bad-attribute-storage-info","Bad attributeStorageInfo specification.")}const U={Float32:Float32Array,Float64:Float64Array,UInt8:Uint8Array,Int8:Int8Array,UInt16:Uint16Array,Int16:Int16Array,UInt32:Uint32Array,Int32:Int32Array},v={Float32:(t,e)=>new DataView(t,0).getFloat32(e,!0),Float64:(t,e)=>new DataView(t,0).getFloat64(e,!0),UInt8:(t,e)=>new DataView(t,0).getUint8(e),Int8:(t,e)=>new DataView(t,0).getInt8(e),UInt16:(t,e)=>new DataView(t,0).getUint16(e,!0),Int16:(t,e)=>new DataView(t,0).getInt16(e,!0),UInt32:(t,e)=>new DataView(t,0).getUint32(e,!0),Int32:(t,e)=>new DataView(t,0).getInt32(e,!0)};function A(t){return U.hasOwnProperty(t)}function I(t){return A(t)?U[t].BYTES_PER_ELEMENT:0}},78395:function(t,e,n){n.d(e,{Gi:function(){return M},IT:function(){return k},ti:function(){return X}});var r=n(88194);const o=!0,i=0,u=10,a=10,c=12,s=16;function f(t,e,n){return{identifier:String.fromCharCode.apply(null,new Uint8Array(t,n+i,u)),version:e.getUint16(n+a,o),checksum:e.getUint32(n+c,o)}}const l=0,d=4,b=8,g=16,w=24,y=32,h=40,p=48,m=56,U=64,v=72,A=80,I=84,C=88;function Z(t,e){return{sizeLo:t.getUint32(e+l,o),sizeHi:t.getUint32(e+d,o),minX:t.getFloat64(e+b,o),minY:t.getFloat64(e+g,o),minZ:t.getFloat64(e+w,o),maxX:t.getFloat64(e+y,o),maxY:t.getFloat64(e+h,o),maxZ:t.getFloat64(e+p,o),errorX:t.getFloat64(e+m,o),errorY:t.getFloat64(e+U,o),errorZ:t.getFloat64(e+v,o),count:t.getUint32(e+A,o),reserved:t.getUint32(e+I,o)}}function M(t){const e=new DataView(t,0);let n=0;const{identifier:o,version:i}=f(t,e,n);if(n+=s,"LEPCC     "!==o)throw new r.Z("lepcc-decode-error","Bad identifier");if(i>1)throw new r.Z("lepcc-decode-error","Unknown version");const u=Z(e,n);if(n+=C,u.sizeHi*2**32+u.sizeLo!==t.byteLength)throw new r.Z("lepcc-decode-error","Bad size");const a=new Float64Array(3*u.count),c=[],l=[],d=[],b=[];if(n=T(t,n,c),n=T(t,n,l),n=T(t,n,d),n=T(t,n,b),n!==t.byteLength)throw new r.Z("lepcc-decode-error","Bad length");let g=0,w=0;for(let t=0;t<c.length;t++){w+=c[t];let e=0;for(let n=0;n<l[t];n++){e+=d[g];const t=b[g];a[3*g]=Math.min(u.maxX,u.minX+2*u.errorX*e),a[3*g+1]=Math.min(u.maxY,u.minY+2*u.errorY*w),a[3*g+2]=Math.min(u.maxZ,u.minZ+2*u.errorZ*t),g++}}return{errorX:u.errorX,errorY:u.errorY,errorZ:u.errorZ,result:a}}function T(t,e,n){const r=[];e=O(t,e,r);const o=[];for(let i=0;i<r.length;i++){o.length=0,e=O(t,e,o);for(let t=0;t<o.length;t++)n.push(o[t]+r[i])}return e}function O(t,e,n){const i=new DataView(t,e),u=i.getUint8(0),a=31&u,c=!!(32&u),s=(192&u)>>6;let f=0;if(0===s)f=i.getUint32(1,o),e+=5;else if(1===s)f=i.getUint16(1,o),e+=3;else{if(2!==s)throw new r.Z("lepcc-decode-error","Bad count type");f=i.getUint8(1),e+=2}if(c)throw new r.Z("lepcc-decode-error","LUT not implemented");const l=Math.ceil(f*a/8),d=new Uint8Array(t,e,l);let b=0,g=0,w=0;const y=-1>>>32-a;for(let t=0;t<f;t++){for(;g<a;)b|=d[w]<<g,g+=8,w+=1;n[t]=b&y,b>>>=a,g-=a,g+a>32&&(b|=d[w-1]>>8-g)}return e+w}const D=0,F=4,E=8,B=12,L=14,S=15,x=16;function z(t,e){return{sizeLo:t.getUint32(e+D,o),sizeHi:t.getUint32(e+F,o),count:t.getUint32(e+E,o),colorMapCount:t.getUint16(e+B,o),lookupMethod:t.getUint8(e+L),compressionMethod:t.getUint8(e+S)}}function k(t){const e=new DataView(t,0);let n=0;const{identifier:o,version:i}=f(t,e,n);if(n+=s,"ClusterRGB"!==o)throw new r.Z("lepcc-decode-error","Bad identifier");if(i>1)throw new r.Z("lepcc-decode-error","Unknown version");const u=z(e,n);if(n+=x,u.sizeHi*2**32+u.sizeLo!==t.byteLength)throw new r.Z("lepcc-decode-error","Bad size");if((2===u.lookupMethod||1===u.lookupMethod)&&0===u.compressionMethod){if(3*u.colorMapCount+u.count+n!==t.byteLength||u.colorMapCount>256)throw new r.Z("lepcc-decode-error","Bad count");const e=new Uint8Array(t,n,3*u.colorMapCount),o=new Uint8Array(t,n+3*u.colorMapCount,u.count),i=new Uint8Array(3*u.count);for(let t=0;t<u.count;t++){const n=o[t];i[3*t]=e[3*n],i[3*t+1]=e[3*n+1],i[3*t+2]=e[3*n+2]}return i}if(0===u.lookupMethod&&0===u.compressionMethod){if(3*u.count+n!==t.byteLength||0!==u.colorMapCount)throw new r.Z("lepcc-decode-error","Bad count");return new Uint8Array(t,n).slice()}if(u.lookupMethod<=2&&1===u.compressionMethod){if(n+3!==t.byteLength||1!==u.colorMapCount)throw new r.Z("lepcc-decode-error","Bad count");const o=e.getUint8(n),i=e.getUint8(n+1),a=e.getUint8(n+2),c=new Uint8Array(3*u.count);for(let t=0;t<u.count;t++)c[3*t]=o,c[3*t+1]=i,c[3*t+2]=a;return c}throw new r.Z("lepcc-decode-error","Bad method "+u.lookupMethod+","+u.compressionMethod)}const P=0,R=4,V=8,_=12,N=14,Y=15,j=16;function H(t,e){return{sizeLo:t.getUint32(e+P,o),sizeHi:t.getUint32(e+R,o),count:t.getUint32(e+V,o),scaleFactor:t.getUint16(e+_,o),bitsPerPoint:t.getUint8(e+N),reserved:t.getUint8(e+Y)}}function X(t){const e=new DataView(t,0);let n=0;const{identifier:o,version:i}=f(t,e,n);if(n+=s,"Intensity "!==o)throw new r.Z("lepcc-decode-error","Bad identifier");if(i>1)throw new r.Z("lepcc-decode-error","Unknown version");const u=H(e,n);if(n+=j,u.sizeHi*2**32+u.sizeLo!==t.byteLength)throw new r.Z("lepcc-decode-error","Bad size");const a=new Uint16Array(u.count);if(8===u.bitsPerPoint){if(u.count+n!==t.byteLength)throw new r.Z("lepcc-decode-error","Bad size");const e=new Uint8Array(t,n,u.count);for(let t=0;t<u.count;t++)a[t]=e[t]*u.scaleFactor}else if(16===u.bitsPerPoint){if(2*u.count+n!==t.byteLength)throw new r.Z("lepcc-decode-error","Bad size");const e=new Uint16Array(t,n,u.count);for(let t=0;t<u.count;t++)a[t]=e[t]*u.scaleFactor}else{const e=[];if(O(t,n,e)!==t.byteLength)throw new r.Z("lepcc-decode-error","Bad size");for(let t=0;t<u.count;t++)a[t]=e[t]*u.scaleFactor}return a}}}]);