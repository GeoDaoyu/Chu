"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[28742,81066,33035],{85968:function(t,e,n){n.d(e,{D:function(){return f},m:function(){return _},s:function(){return y},w:function(){return d}});var i=n(73440),s=n(10057),a=n(11894),r=n(65513),o=n(9519),m=n(64699),h=n(60988);function _(){return{outPoint:new o.P,index:-1,t:Number.NaN}}function u(t,e,n){return{outPoint:t.clone(),index:e,t:n}}function c(t,e,n,i){t.outPoint.assign(e),t.index=n,t.t=i}function l(t,e){t.outPoint.assign(e.outPoint),t.index=e.index,t.t=e.t}function p(t,e,n,i){t.index=n,t.t=i,e.queryCoord2D(t.t,t.outPoint)}function g(t,e){const n=_();l(n,t),l(t,e),l(e,n)}function d(t,e,n,i,a,o){if(t.getGeometryType()===s.G.enumPolygon){for(;i.nextPath();)if(i.hasNextSegment()){const e=i.nextSegment();if(0!==(0,r.h)(t,e.getEndXY(),0))return c(a,e.getEndXY(),-1,Number.NaN),c(o,e.getEndXY(),-1,Number.NaN),!0}i.resetToFirstPath()}if(e.getGeometryType()===s.G.enumPolygon){for(;n.nextPath();)if(n.hasNextSegment()){const t=n.nextSegment();if(0!==(0,r.h)(e,t.getEndXY(),0))return c(a,t.getEndXY(),-1,Number.NaN),c(o,t.getEndXY(),-1,Number.NaN),!0}n.resetToFirstPath()}return!1}function y(t){const e=t.getPathCount(),n=(0,o.d)(t.getSegmentCount(),0);let i=0;for(let s=0;s<e;++s){const e=i+t.getSegmentCountPath(s);for(let a=i,r=t.getPathStart(s);a<e;++a,++r)n[a]=r;i=e}return(0,a.s)(t.getPointCount(),n),n}function P(t,e){return!!Number.isNaN(e)||t<=e}function x(t){const e=new a.a;return e.addEnvelope(t,!1),e}class f{constructor(t,e){if(this.m_env2DgeometryA=null,this.m_env2DgeometryB=null,this.m_progressCounter=0,this.m_progressTracker=e,this.m_maxSqrDistance=t*t,this.m_maxDistance=t,this.m_bIsNearCalc=!1,Number.isNaN(this.m_maxDistance)?this.m_maxDistance=Number.POSITIVE_INFINITY:this.m_maxDistance=t,this.m_maxSqrDistance=this.m_maxDistance*this.m_maxDistance,Number.isFinite(this.m_maxSqrDistance)){let t=Math.sqrt(this.m_maxSqrDistance);for(;t<this.m_maxDistance;)this.m_maxSqrDistance*=1+Number.EPSILON,t=Math.sqrt(this.m_maxSqrDistance)}}calculate(t,e,n,i){if((t.getGeometryType()!==h.P.type||e.getGeometryType()!==h.P.type)&&(this.m_env2DgeometryA=new m.Envelope2D,this.m_env2DgeometryB=new m.Envelope2D,t.queryEnvelope(this.m_env2DgeometryA),e.queryEnvelope(this.m_env2DgeometryB),!P(this.m_env2DgeometryA.distanceFromEnvelope(this.m_env2DgeometryB),this.m_maxDistance)))return Number.POSITIVE_INFINITY;const s=u(new o.P,(0,o.j)(),Number.NaN),a=u(new o.P,(0,o.j)(),Number.NaN),r=this._ExecuteBruteForce(t,e,s,a);return P(r,this.m_maxDistance)?(null!==n&&l(n,s),null!==i&&l(i,a),r):Number.POSITIVE_INFINITY}isNear(t,e){if(this.m_bIsNearCalc=!0,t.isEmpty()||e.isEmpty())return!1;if(t===e)return!0;let n=!0;if(t.getGeometryType()!==h.P.type&&t.getGeometryType()!==h.E.type||e.getGeometryType()!==h.P.type&&e.getGeometryType()!==h.E.type||(n=!1),n){if(this.m_env2DgeometryA=new m.Envelope2D,this.m_env2DgeometryB=new m.Envelope2D,t.queryEnvelope(this.m_env2DgeometryA),e.queryEnvelope(this.m_env2DgeometryB),!(this.m_env2DgeometryA.sqrMaxMinDistanceEnvelope(this.m_env2DgeometryB)>this.m_maxSqrDistance))return!0;if(this.m_env2DgeometryA.sqrDistanceEnvelope(this.m_env2DgeometryB,null,null)>this.m_maxSqrDistance)return!1}const i=u(new o.P,(0,o.j)(),Number.NaN),s=u(new o.P,(0,o.j)(),Number.NaN);return this._ExecuteBruteForce(t,e,i,s)<=this.m_maxDistance}progress_(t=!1){}_ExecuteBruteForce(t,e,n,i){switch(t.getGeometryType()){case s.G.enumPoint:return this.distancePointGeometry(t,e,n,i);case s.G.enumMultiPoint:return this.distanceMultipointGeometry(t,e,n,i);case s.G.enumEnvelope:return this.distanceEnvelopeGeometry(t,e,n,i);case s.G.enumPolyline:case s.G.enumPolygon:return this.distanceMultipathGeometry(t,e,n,i);default:return Number.NaN}}distancePointGeometry(t,e,n,i){switch(e.getGeometryType()){case s.G.enumPoint:return this.distancePointPoint(t,e,n,i);case s.G.enumMultiPoint:return this.distancePointMultipoint(t,e,n,i);case s.G.enumPolyline:case s.G.enumPolygon:return this.distancePointMultipath(t,e,n,i);case s.G.enumEnvelope:return this.distancePointEnvelope(t,e,n,i);default:return Number.NaN}}distancePointPoint(t,e,n,i){const s=t.getXY(),a=e.getXY();return c(n,s,0,0),c(i,a,0,0),Math.sqrt(o.P.sqrDistance(s,a))}distancePointMultipoint(t,e,n,i){const s=t.getXY();let a=this.m_maxSqrDistance,r=a,m=!1;const h=e.getPointCount(),_=new o.P;for(let t=0;t<h;++t)if(e.queryXY(t,_),r=o.P.sqrDistance(s,_),this.m_bIsNearCalc){if(r<=a)return 0}else if(!(r>a)&&(!m&&r===a||r<a)&&(a=r,c(n,s,0,0),c(i,_,t,0),m=!0,0===a))return 0;return m?Math.sqrt(a):Number.POSITIVE_INFINITY}distancePointMultipath(t,e,n,i){const a=!this.m_env2DgeometryA.isIntersecting(this.m_env2DgeometryB),h=t.getXY();if(!a&&e.getGeometryType()===s.G.enumPolygon&&0!==(0,r.h)(e,h,0))return c(n,h,0,0),c(i,h,-1,Number.NaN),0;e.getImpl().getAccelerators();let _=this.m_maxSqrDistance,u=_,l=-1;const p=new m.Envelope2D,g=e.querySegmentIterator();let d=!1;for(;g.nextPath();)for(;g.hasNextSegment();){const t=g.nextSegment();t.queryEnvelope(p);const e=p.sqrDistance(h);if(e>_)continue;if(!this.m_bIsNearCalc&&d&&e===_)continue;l=t.getClosestCoordinate(h,!1);const s=t.getCoord2D(l);if(u=o.P.sqrDistance(h,s),this.m_bIsNearCalc){if(u<=_)return 0}else if(!(u>_)&&(!d||u<_)&&(_=u,c(n,h,0,0),c(i,s,g.getStartPointIndex(),l),d=!0,0===_))return 0}return d?Math.sqrt(_):Number.POSITIVE_INFINITY}distancePointEnvelope(t,e,n,i){const s=t.getXY();c(n,s,0,0),c(i,s,-1,Number.NaN);const a=e.asEnvelope2D();return a.contains(s)?0:Math.sqrt(a.sqrDistance(s,i.outPoint))}distanceMultipointGeometry(t,e,n,i){switch(e.getGeometryType()){case s.G.enumPoint:{this.m_env2DgeometryB=(0,o.c)(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB);const s=this.distancePointMultipoint(e,t,i,n);return this.m_env2DgeometryB=(0,o.c)(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB),s}case s.G.enumMultiPoint:return this.distanceMultipointMultipoint(t,e,n,i,1,1);case s.G.enumPolyline:case s.G.enumPolygon:return this.distanceMultipointMultipath(t,e,n,i);case s.G.enumEnvelope:return this.distanceMultipointMultipath(t,x(e),n,i);default:return Number.NaN}}distanceMultipointMultipoint(t,e,n,s,a,r){const m={stack:[],error:void 0,hasError:!1};try{if(this.m_bIsNearCalc&&1===a&&1===r){const i=Math.trunc((0,o.s)(Math.sqrt(t.getPointCount())+1,1,(0,o.i)())),a=Math.trunc((0,o.s)(Math.sqrt(e.getPointCount())+1,1,(0,o.i)()));if((i>=4||a>=4)&&this.distanceMultipointMultipoint(t,e,n,s,i,a)<=this.m_maxSqrDistance)return 0}let h=this.m_maxSqrDistance;const _=[t],u=[e],l=this.swapGeometriesIfBGtA(_,u);l&&(this.m_env2DgeometryB=(0,o.c)(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB),r=(0,o.c)(a,a=r),g(n,s)),(0,i.b)(m,(0,o.h)((()=>{g(n,s),this.m_env2DgeometryB=(0,o.c)(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB)}),!l),!1);const p=_[0].getImpl(),d=u[0].getImpl(),y=p.getPointCount(),P=d.getPointCount(),x=P>1;let f=!1;const S=new o.P,E=new o.P;for(let t=0;t<y;t+=a){if(p.queryXY(t,S),x){const t=this.m_env2DgeometryB.sqrDistance(S);if(this.m_bIsNearCalc){if(t>h)continue;if(this.m_env2DgeometryB.sqrMaxMinDistance(S)<=h)return 0}else if(t>=h)continue}for(let e=0;e<P;e+=r){d.queryXY(e,E);const i=o.P.sqrDistance(S,E);if(this.m_bIsNearCalc){if(i<=h)return 0}else if(!(i>h||f&&i===h)&&(!f||i<h)&&(c(n,S,t,0),c(s,E,e,0),f=!0,h=i,0===h))return f?Math.sqrt(h):Number.POSITIVE_INFINITY}}return f?Math.sqrt(h):Number.POSITIVE_INFINITY}catch(t){m.error=t,m.hasError=!0}finally{(0,i.c)(m)}}distanceMultipointMultipath(t,e,n,i){let a=!!this.m_env2DgeometryA.isIntersecting(this.m_env2DgeometryB)&&e.getGeometryType()===s.G.enumPolygon;const h=e.querySegmentIterator();h.stripAttributes();const _=new m.Envelope2D,u=new o.P;let l=this.m_maxSqrDistance;const p=t.getImpl(),g=p.getPointCount(),d=g>1;let y=!1;for(;h.nextPath();)for(;h.hasNextSegment();){const t=h.nextSegment();if(t.queryLooseEnvelope(_),d){const t=_.sqrDistanceEnvelope(this.m_env2DgeometryA,null,null);if(this.m_bIsNearCalc){if(t>l)continue}else if(t>l||y&&t===l)continue}for(let s=0;s<g;s++){if(p.queryXY(s,u),a&&0!==(0,r.h)(e,u,0))return c(n,u,-1,Number.NaN),c(i,u,s,0),0;{const t=_.sqrDistance(u);if(this.m_bIsNearCalc){if(t>l)continue}else if(t>l)continue}const o=t.getClosestCoordinate(u,!1),m=t.getCoord2D(o);u.subThis(m);const g=u.sqrLength();if(this.m_bIsNearCalc){if(g<=l)return 0}else if(!(g>l)&&(!y||g<l)&&(l=g,c(n,p.getXY(s),s,0),c(i,m,h.getStartPointIndex(),o),y=!0,0===l))return 0}a=!1}return y?Math.sqrt(l):Number.POSITIVE_INFINITY}distanceEnvelopeGeometry(t,e,n,i){switch(e.getGeometryType()){case s.G.enumPoint:return this.distancePointEnvelope(e,t,i,n);case s.G.enumMultiPoint:{this.m_env2DgeometryB=(0,o.c)(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB);const s=this.distanceMultipointMultipath(e,x(t),i,n);return this.m_env2DgeometryB=(0,o.c)(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB),s}case s.G.enumPolyline:case s.G.enumPolygon:return this.distanceMultipathMultipath(x(t),e,n,i);case s.G.enumEnvelope:return this.distanceEnvelopeEnvelope(t,e,n,i);default:return Number.NaN}}distanceEnvelopeEnvelope(t,e,n,i){n.t=Number.NaN,n.index=-1,i.t=Number.NaN,i.index=-1;const s=t.asEnvelope2D(),a=e.asEnvelope2D();return Math.sqrt(s.sqrDistanceEnvelope(a,n.outPoint,i.outPoint))}distanceMultipathGeometry(t,e,n,i){switch(e.getGeometryType()){case s.G.enumPoint:{this.m_env2DgeometryB=(0,o.c)(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB);const s=this.distancePointMultipath(e,t,i,n);return this.m_env2DgeometryB=(0,o.c)(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB),s}case s.G.enumMultiPoint:{this.m_env2DgeometryB=(0,o.c)(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB);const s=this.distanceMultipointMultipath(e,t,i,n);return this.m_env2DgeometryB=(0,o.c)(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB),s}case s.G.enumPolyline:case s.G.enumPolygon:return this.distanceMultipathMultipath(t,e,n,i);case s.G.enumEnvelope:return this.distanceMultipathMultipath(t,x(e),n,i);default:return Number.NaN}}distanceMultipathMultipath(t,e,n,s){const r={stack:[],error:void 0,hasError:!1};try{const h=[t],u=[e],c=this.swapGeometriesIfAGtB(h,u);c&&(this.m_env2DgeometryB=(0,o.c)(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB),g(n,s)),(0,i.b)(r,(0,o.h)((()=>{g(n,s),this.m_env2DgeometryB=(0,o.c)(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB)}),!c),!1);const P=h[0],x=u[0],f=P.querySegmentIterator();f.stripAttributes();const S=x.querySegmentIterator();if(S.stripAttributes(),this.m_bIsNearCalc&&this.m_env2DgeometryA.sqrMaxMinDistanceEnvelope(this.m_env2DgeometryB)<=this.m_maxSqrDistance)return 0;if(this.m_bIsNearCalc){const t=Math.trunc((0,o.s)(Math.sqrt(P.getPointCount())+1,1,(0,o.i)())),e=Math.trunc((0,o.s)(Math.sqrt(P.getPointCount())+1,1,(0,o.i)()));if(this.distanceMultipointMultipoint(P,x,n,s,t,e)<=this.m_maxSqrDistance)return 0}if(this.m_env2DgeometryA.isIntersecting(this.m_env2DgeometryB)){const t=_(),e=_();if(d(P,x,f,S,t,e))return l(n,t),l(s,e),0}const E=y(P),v=[],D=new a.S,G=new m.Envelope2D,M=new m.Envelope2D,w=new m.Envelope2D;let T=this.m_maxSqrDistance,b=!0,A=!1;for(let t=0,e=E.length;t<e;++t){P.querySegment(E[t],D,!0);const e=D.get();if(e.queryEnvelope(G),!(G.sqrDistanceEnvelope(this.m_env2DgeometryB,null,null)>T)){if(this.m_bIsNearCalc&&G.sqrMaxDistanceEnvelope(this.m_env2DgeometryB)<=T)return 0;for(;S.nextPath();){if(this.progress_(),b)x.queryPathEnvelope(S.getPathIndex(),w),v[S.getPathIndex()]=w.clone();else if(G.sqrDistanceEnvelope(v[S.getPathIndex()],null,null)>T)continue;for(;S.hasNextSegment();){const i=S.nextSegment();if(i.queryEnvelope(M),G.sqrDistanceEnvelope(M,null,null)<=T){const a=!G.isIntersecting(M),r=[0],o=[0];let m=e.distance(i,a,r,o);if(m*=m,this.m_bIsNearCalc&&m<=this.m_maxSqrDistance)return 0;if(m<T||m===T&&E[t]<n.index){if(A=!0,p(n,e,E[t],r[0]),p(s,i,S.getStartPointIndex(),o[0]),0===m)return 0;T=m}}}}S.resetToFirstPath(),b=!1}}return A?Math.sqrt(T):Number.POSITIVE_INFINITY}catch(t){r.error=t,r.hasError=!0}finally{(0,i.c)(r)}}swapGeometriesIfAGtB(t,e){return(0,s.v)(t[0])>(0,s.v)(e[0])&&(e[0]=(0,o.c)(t[0],t[0]=e[0]),!0)}swapGeometriesIfBGtA(t,e){return this.swapGeometriesIfAGtB(e,t)}}},28742:function(t,e,n){n.r(e),n.d(e,{OperatorGeodeticArea:function(){return I}});var i=n(10057),s=n(11894),a=n(95016),r=n(65513),o=n(9519),m=n(64699),h=n(60988),_=n(12069),u=n(83264),c=n(73440),l=n(66288);n(85968),n(81066),n(33035);class p{[Symbol.dispose](){this.m_peR1.destroy(),this.m_peR2.destroy(),this.m_peR3.destroy(),this.m_peR1=null,this.m_peR2=null,this.m_peR3=null}constructor(t,e,n){this.m_peR1=new r.P,this.m_peR2=new r.P,this.m_peR3=new r.P,void 0!==t?this.reset(t,e,n):this.reset(1,0,1)}reset(t,e,n){this.m_a=t,this.m_e2=e,this.m_b=this.m_a*Math.sqrt(1-this.m_e2),this.m_unitToDegree=n,this.m_unitToRad=.017453292519943295*n,this.m_u180=180/this.m_unitToDegree,this.m_u360=360/this.m_unitToDegree}calculateBbox(t,e,n,i){const s=this.m_peR1,a=this.m_peR2,h=this.m_peR3;r.z.geodeticDistance(this.m_a,this.m_e2,t*this.m_unitToRad,e*this.m_unitToRad,n*this.m_unitToRad,i*this.m_unitToRad,h,s,a,0);const _=Math.cos(s.val),u=Math.cos(a.val+3.141592653589793),c=e*this.m_unitToRad,l=r.J.phiToEta(this.m_e2,c),p=Math.sin(s.val)*Math.cos(l);let g=e;if(_*u<0){const t=_<0?-1:1,e=Math.acos(Math.abs(p))*t;r.J.etaToPhi(this.m_e2,e)/this.m_unitToRad}let d=(0,o.l)((n-t)*this.m_unitToRad,2*Math.PI);Math.abs(d)>Math.PI&&(d>0?d-2*Math.PI:d+2*Math.PI),this.m_unitToRad,t+d;const y=new m.Envelope2D;return y.xmin=Math.min(t,n),y.xmax=Math.max(t,n),y.ymin=Math.min(e,i),y.ymin=Math.min(y.ymin,g),y.ymax=Math.max(e,i),y.ymax=Math.max(y.ymax,g),y}minDistanceGeodesic(t,e){const n=O(t),i=O(e);if(n&&i)return this.lowerDistanceGeodetic_(t.xmin,t.ymin,e.xmin,e.ymin);const s=this.normalizeGeodesic_(e,t);return function(t,e){return e.xmax<t.xmin||e.xmin>t.xmax||e.ymax<t.ymin||e.ymin>t.ymax}(t,s)?t.ymin>=s.ymax?this.minDistanceGeodesicUpDown_(t,s):s.ymin>=t.ymax?this.minDistanceGeodesicUpDown_(s,t):t.xmin>s.xmax?this.minDistanceGeodesicLeftRight_(s,t):this.minDistanceGeodesicLeftRight_(t,s):0}normalizeGeodesic_(t,e){const n=t.clone(),i=t.clone();let s=V(n,e);if(0===s)return n;for(;i.xmax>e.xmin;){i.xmin-=this.m_u360,i.xmax-=this.m_u360;const t=V(i,e);if(t<s&&(n.assign(i),t,0===s))return n}for(i.assign(t);i.xmin<e.xmax;){i.xmin+=this.m_u360,i.xmax+=this.m_u360;const t=V(i,e);if(t<s&&(n.assign(i),t,0===s))return n}return n}lowerDistanceGeodetic_(t,e,n,i){const s=this.m_peR1;{const a=this.m_b*this.m_b/this.m_a,o=r.J.phiToPhig(this.m_e2,this.m_unitToRad*e),m=r.J.phiToPhig(this.m_e2,this.m_unitToRad*i);r.z.geodeticDistance(a,0,this.m_unitToRad*t,o,this.m_unitToRad*n,m,s,null,null,0)}return s.val}minDistanceGeodesicUpDown_(t,e){if(e.xmin<=t.xmin?e.xmax>=t.xmin:t.xmax>=e.xmin)return this.lowerDistanceGeodetic_(0,t.ymin,0,e.ymax);if(e.xmin>t.xmax){const n=this.lowerDistanceGeodeticSegMeridional_(t.xmax,t.ymin,t.ymax,e.xmin,e.ymin,e.ymax);if(e.xmax-t.xmin<this.m_u180)return n;const i=this.lowerDistanceGeodeticSegMeridional_(t.xmin,t.ymin,t.ymax,e.xmax,e.ymin,e.ymax);return Math.min(n,i)}{const n=this.lowerDistanceGeodeticSegMeridional_(t.xmin,t.ymin,t.ymax,e.xmax,e.ymin,e.ymax);if(t.xmax-e.xmin<this.m_u180)return n;const i=this.lowerDistanceGeodeticSegMeridional_(t.xmax,t.ymin,t.ymax,e.xmin,e.ymin,e.ymax);return Math.min(n,i)}}minDistanceGeodesicLeftRight_(t,e){let n=Math.abs(t.xmax-e.xmin);for(;n>this.m_u180;)this.m_u360;let i=Math.abs(t.xmin-e.xmax);for(;i>this.m_u180;)this.m_u360;return Math.abs(n)<=Math.abs(i)?this.minDistanceGeodesicLeftRightNormalized_(t,e):this.minDistanceGeodesicLeftRightNormalized_(e,t)}minDistanceGeodesicLeftRightNormalized_(t,e){let n,i;return this.lowerDistanceGeodetic_(t.xmax,t.ymin,e.xmin,e.ymin),t.ymin>=e.ymin&&t.ymin<=e.ymax&&(this.lowerDistanceGeodeticPtMeridional_(t.xmax,t.ymin,e.xmin,e.ymin,e.ymax),Math.min(n,i)),e.ymin>=t.ymin&&e.ymin<=t.ymax&&(this.lowerDistanceGeodeticPtMeridional_(e.xmin,e.ymin,t.xmax,t.ymin,t.ymax),Math.min(n,i)),this.lowerDistanceGeodetic_(t.xmax,t.ymax,e.xmin,e.ymax),Math.min(n,i),t.ymax>=e.ymin&&t.ymax<=e.ymax&&(this.lowerDistanceGeodeticPtMeridional_(t.xmax,t.ymax,e.xmin,e.ymin,e.ymax),Math.min(n,i)),e.ymax>=t.ymin&&e.ymax<=t.ymax&&(this.lowerDistanceGeodeticPtMeridional_(e.xmin,e.ymax,t.xmax,t.ymin,t.ymax),Math.min(n,i)),n}lowerDistanceGeodeticSegMeridional_(t,e,n,i,s,a){let r=this.lowerDistanceGeodeticPtMeridional_(t,e,i,s,a);const o=this.lowerDistanceGeodeticPtMeridional_(t,n,i,s,a);let m=this.lowerDistanceGeodeticPtMeridional_(i,s,t,e,n);const h=this.lowerDistanceGeodeticPtMeridional_(i,a,t,e,n);return Math.min(r,o),Math.min(m,h),Math.min(r,m)}lowerDistanceGeodeticPtMeridional_(t,e,n,i,s){const a=this.m_b*this.m_b/this.m_a,m=r.J.phiToPhig(this.m_e2,this.m_unitToRad*e),_=r.J.phiToPhig(this.m_e2,this.m_unitToRad*i),u=r.J.phiToPhig(this.m_e2,this.m_unitToRad*s),c=this.m_peR1,l=this.m_peR2;r.z.geodeticDistance(a,0,this.m_unitToRad*n,_,this.m_unitToRad*t,m,c,null,null,0),r.z.geodeticDistance(a,0,this.m_unitToRad*n,u,this.m_unitToRad*t,m,l,null,null,0);const p=(0,r.w)(1,0,new o.P(this.m_unitToRad*t,m)),g=(0,r.w)(1,0,new o.P(this.m_unitToRad*n,_)),d=(0,r.w)(1,0,new o.P(this.m_unitToRad*n,u));let y=new h.d;y.setCrossProductVector(g,d);const P=g.dotProduct(d);if(y.length()<1.568e-10)return P>=0?Math.min(c.val,l.val):0;y.getUnitVector();let x=new h.d;if(x.setCrossProductVector(y,p),x.length()<1.568e-10)return Math.min(c.val,l.val)-1e-5*a;x.getUnitVector();let f=p.sub(y.mul(p.dotProduct(y)));{const e=new h.d;e.setCrossProductVector(g,f);const n=new h.d;n.setCrossProductVector(f,d);let i=y.dotProduct(e)>0&&y.dotProduct(n)>0;if(i||(f.negateThis(),e.setCrossProductVector(g,f),n.setCrossProductVector(f,d),y.dotProduct(e)>0&&y.dotProduct(n)>0),i){f.getUnitVector();const e=(0,r.y)(1,0,f),n=this.m_peR3;r.z.geodeticDistance(a,0,this.m_unitToRad*t,m,e.x,e.y,n,null,null,0);const i=Math.min(c.val,l.val);return Math.min(i,n.val)}}return Math.min(c.val,l.val)}}class g{constructor(t,e,n,i,s=0,a=4){this.m_ptDistFrom=new o.P,this.m_segStartPt=new o.P,this.m_segEndPt=new o.P,this.m_geodeticLength=new r.P,this.m_az12=new r.P,this.m_minGeodeticDist=new r.P,this.m_segStartPt3d=new h.d,this.m_segEndPt3d=new h.d,this.m_sr=i,this.m_distCurveType=s,this.m_segCurveType=a,this.m_inputGCS=this.m_sr.getGCS(),this.m_rpu=this.m_inputGCS.getUnit().getUnitToBaseFactor(),this.m_bIsPannablePcs=2===this.m_sr.getCoordinateSystemType()&&this.m_sr.isPannable();const m=(0,r.v)();this.m_inputGCS.querySpheroidData(m),this.m_a=m.majorSemiAxis,this.m_eSquared=m.e2,this.setPointDistFrom(t),this.setSegmentEndPoints(e,n)}setSegmentEndPoints(t,e){this.m_segStartPt.assign(t),this.m_segEndPt.assign(e),this.m_bIsPannablePcs||(this.m_segStartPt.mulThis(this.m_rpu),this.m_segEndPt.mulThis(this.m_rpu)),2===this.m_segCurveType&&(this.m_segStartPt3d.assign((0,r.w)(this.m_a,this.m_eSquared,this.m_segStartPt)),this.m_segEndPt3d.assign((0,r.w)(this.m_a,this.m_eSquared,this.m_segEndPt))),this.calculateAndUpdateSegmentLength()}setPointDistFrom(t){this.m_ptDistFrom.assign(t),this.m_ptDistFrom.scale(this.m_rpu)}setSegmentCurveType(t){this.m_segCurveType=t}setDistanceCurveType(t){this.m_distCurveType=t}makeFunctor(){return t=>{let e;switch(this.m_segCurveType){case 0:case 1:case 3:{const n={stack:[],error:void 0,hasError:!1};try{const i=(0,c.b)(n,new r.P,!1),s=(0,c.b)(n,new r.P,!1);r.z.geodeticCoordinate(this.m_a,this.m_eSquared,this.m_segStartPt.x,this.m_segStartPt.y,this.m_geodeticLength.val*t,this.m_az12.val,i,s,this.m_segCurveType),e=new o.P(i.val,s.val);break}catch(t){n.error=t,n.hasError=!0}finally{(0,c.c)(n)}}case 2:{const n=h.d.lerp(this.m_segStartPt3d,this.m_segEndPt3d,t);e=(0,r.y)(this.m_a,this.m_eSquared,n);break}case 4:e=o.P.lerp(this.m_segStartPt,this.m_segEndPt,t),this.m_bIsPannablePcs&&((0,r.x)(this.m_sr,0,[e],1),e.mulThis(this.m_rpu));break;default:(0,i.d)("Invalid curve type")}return r.z.geodeticDistance(this.m_a,this.m_eSquared,this.m_ptDistFrom.x,this.m_ptDistFrom.y,e.x,e.y,this.m_minGeodeticDist,null,null,this.m_distCurveType),this.m_minGeodeticDist.val}}calculateAndUpdateSegmentLength(){switch(this.m_segCurveType){case 0:case 2:case 1:case 3:r.z.geodeticDistance(this.m_a,this.m_eSquared,this.m_segStartPt.x,this.m_segStartPt.y,this.m_segEndPt.x,this.m_segEndPt.y,this.m_geodeticLength,this.m_az12,null,this.m_segCurveType);break;case 4:this.m_geodeticLength.val=o.P.distance(this.m_segStartPt,this.m_segEndPt);break;default:(0,i.d)("Invalid curve type")}}[Symbol.dispose](){this.m_geodeticLength[Symbol.dispose](),this.m_az12[Symbol.dispose](),this.m_minGeodeticDist[Symbol.dispose]()}}class d{[Symbol.dispose](){this.m_envHelper[Symbol.dispose]()}constructor(t,e,n,i,s){this.m_boxGeomA=H(),this.m_boxGeomB=H(),this.m_envGeomA=new m.Envelope2D,this.m_envGeomB=new m.Envelope2D,this.m_progressCounter=0,this.m_transformPCS2GCS=null,this.m_segmentBoxesA=new Map,this.m_segmentBoxesB=new Map,this.m_boundaryPtsA=[],this.m_boundaryPtsB=[],this.m_scaleToRadians=new l.T,this.m_scaleToDegrees=new l.T,this.m_inputSR=t,this.m_distCurveType=e,this.m_progressTracker=n,this.m_maxDistance=i,this.m_maxDeviation=s,this.m_inputGCS=t.getGCS(),this.m_peGeogcs=this.m_inputGCS.getPECoordSys(),this.m_tolerance=0;const a=(0,r.v)();this.m_inputGCS.querySpheroidData(a),this.m_a=a.majorSemiAxis,this.m_eSquared=a.e2,this.m_rpu=this.m_inputGCS.getUnit().getUnitToBaseFactor(),this.m_envHelper=new p(this.m_a,this.m_eSquared,1),4===this.m_distCurveType&&(this.m_distCurveType=0),this.m_boxGeomA.setEmpty(),this.m_boxGeomB.setEmpty(),this.m_envGeomA.setEmpty(),this.m_envGeomB.setEmpty(),this.m_bIsPannablePcs=2===this.m_inputSR.getCoordinateSystemType()&&this.m_inputSR.isPannable()}progress(t=!1){}calculate(t,e,n,i){const s=L(),a=L();if(t.queryEnvelope(this.m_envGeomA),e.queryEnvelope(this.m_envGeomB),this.checkGeometriesIntersect(t,e,s,a))return n&&z(n,s),i&&z(i,a),0;const r=this.prepareGeometry(t);if(r.isEmpty())return Number.NaN;const o=this.prepareGeometry(e);if(o.isEmpty())return Number.NaN;this.m_tolerance=this.computeTolerance(r,o);const m=this._ExecuteBruteForce(r,o,s,a);return m>=this.m_maxDistance?Number.NaN:(n&&(this.prepareOutput(s),z(n,s)),i&&(this.prepareOutput(a),z(i,a)),m)}createDistanceFunctor(t,e,n){const i=new g(t,e,n,this.m_inputSR,this.m_distCurveType);return this.m_bIsPannablePcs||1===this.m_inputSR.getCoordinateSystemType()||i.setSegmentCurveType(2),i}_NormalizeAndProject(t){if(this.m_inputSR.isPannable()&&(new r.A).foldInto360Range(t,this.m_inputSR),2===this.m_inputSR.getCoordinateSystemType()){const e=(0,r.B)(this.m_inputSR,this.m_inputGCS,null);(new r.A).execute(t,e,this.m_progressTracker)}return t}_ExecuteBruteForce(t,e,n,s){switch(t.getGeometryType()){case i.G.enumPoint:return this.calculateDistanceGeodeticPointGeometry(t,e,n,s);case i.G.enumMultiPoint:return this.calculateDistanceGeodeticMultipointGeometry(t,e,n,s);case i.G.enumPolyline:case i.G.enumPolygon:case i.G.enumEnvelope:return this.calculateDistanceGeodeticMultipathGeometry(t,e,n,s);default:(0,i.a)("")}}calculateDistanceGeodeticPointGeometry(t,e,n,s){switch(e.getGeometryType()){case i.G.enumPoint:return this.calculateDistanceGeodeticPointPoint(t,e,n,s);case i.G.enumMultiPoint:return this.calculateDistanceGeodeticPointMultipoint(t,e,n,s);case i.G.enumPolyline:case i.G.enumPolygon:return this.calculateDistanceGeodeticPointMultipath(t,e,n,s);default:(0,i.a)("")}}calculateDistanceGeodeticPointPoint(t,e,n,i){const s={stack:[],error:void 0,hasError:!1};try{const a=t.getXY();a.scale(this.m_rpu);const o=e.getXY();o.scale(this.m_rpu),n.outPoint.assign(a),i.outPoint.assign(o);const m=(0,c.b)(s,new r.P,!1);return r.z.geodeticDistance(this.m_a,this.m_eSquared,a.x,a.y,o.x,o.y,m,null,null,this.m_distCurveType),m.val}catch(t){s.error=t,s.hasError=!0}finally{(0,c.c)(s)}}calculateDistanceGeodeticPointMultipoint(t,e,n,i){const s={stack:[],error:void 0,hasError:!1};try{this.computeEnvelopesAndBoxes(t,e);const a=this.estimateMinimumDistance(n,i);let m=a<this.m_maxDistance?a:this.m_maxDistance;const _=t.getXY();_.scale(this.m_rpu),n.outPoint.assign(_);const u=(0,r.w)(this.m_a,this.m_eSquared,_),l=new o.P,p=e.getImpl(),g=(0,c.b)(s,new r.P,!1),d=p.getPointCount();for(let t=0;t<d;++t){p.queryXY(t,l),l.scale(this.m_rpu);const e=(0,r.w)(this.m_a,this.m_eSquared,l);if(!(h.d.distance(u,e)>m)&&!(this.m_envHelper.minDistanceGeodesic(this.m_boxGeomA,this.m_boxGeomB)>m)&&(r.z.geodeticDistance(this.m_a,this.m_eSquared,_.x,_.y,l.x,l.y,g,null,null,this.m_distCurveType),g.val<m&&(g.val,i.outPoint=l,0===m)))return m}return m===this.m_maxDistance?Number.POSITIVE_INFINITY:m}catch(t){s.error=t,s.hasError=!0}finally{(0,c.c)(s)}}calculateDistanceGeodeticPointMultipath(t,e,n,s){const a={stack:[],error:void 0,hasError:!1};try{const m=new o.P,h=new o.P;m.assign(t.getXY()),h.assign(t.getXY()),n.outPoint.assign(h.mul(this.m_rpu)),this.m_bIsPannablePcs&&(0,r.D)(this.m_inputSR,[m],1,!1),this.computeEnvelopesAndBoxes(t,e);const _=this.estimateMinimumDistance(n,s);let u=_<this.m_maxDistance?_:this.m_maxDistance;const l=e.getImpl(),p=new o.P(0,0),g=new o.P(0,0),d=[1],y=this.canUseSpatialTree(t,e),P=K();y&&this.buildSpatialTree(P,e);const x=H();x.setCoords({xmin:h.x,ymin:h.y,xmax:h.x,ymax:h.y});const f=(0,c.b)(a,this.createDistanceFunctor(h,p,g),!1),S=l.querySegmentIterator();if(S.stripAttributes(),y)(0,i.g)(0);else for(;S.nextPath();)for(;S.hasNextSegment();){const t=S.nextSegment(),e=this.findOrComputeBoxSegment(S.getStartPointIndex(),t,this.m_segmentBoxesB);if(this.m_envHelper.minDistanceGeodesic(x,e)>u)continue;const n=this.calculateDistanceGeodeticPointSegment(m,h,t,d,f);if(n.second<u&&(this.updateOutputSegment(s,t,n.first),n.second,0===u))return 0}return u===this.m_maxDistance?Number.POSITIVE_INFINITY:u}catch(t){a.error=t,a.hasError=!0}finally{(0,c.c)(a)}}calculateDistanceGeodeticMultipointGeometry(t,e,n,s){switch(e.getGeometryType()){case i.G.enumPoint:return this.calculateDistanceGeodeticPointMultipoint(e,t,s,n);case i.G.enumMultiPoint:return this.calculateDistanceGeodeticMultipointMultipoint(t,e,n,s);case i.G.enumPolyline:case i.G.enumPolygon:case i.G.enumEnvelope:return this.calculateDistanceGeodeticMultipointMultipath(t,e,n,s);default:(0,i.a)("")}}calculateDistanceGeodeticMultipointMultipoint(t,e,n,i){const s={stack:[],error:void 0,hasError:!1};try{const a=(0,c.b)(s,new r.P,!1);this.computeEnvelopesAndBoxes(t,e);const m=this.estimateMinimumDistance(n,i);let _=m<this.m_maxDistance?m:this.m_maxDistance;const u=new o.P,l=new o.P,p=t.getImpl(),g=e.getImpl(),d=H(),y=p.getPointCount(),P=g.getPointCount();for(let t=0;t<y;++t){if(u.assign(p.getXY(t)),d.setCoords({xmin:u.x,ymin:u.y,xmax:u.x,ymax:u.y}),this.m_envHelper.minDistanceGeodesic(d,this.m_boxGeomB)>_)continue;u.scale(this.m_rpu);const e=(0,r.w)(this.m_a,this.m_eSquared,u);for(let t=0;t<P;++t){l.assign(g.getXY(t)),l.scale(this.m_rpu);const s=(0,r.w)(this.m_a,this.m_eSquared,l);if(!(h.d.distance(e,s)>=_)&&(r.z.geodeticDistance(this.m_a,this.m_eSquared,u.x,u.y,l.x,l.y,a,null,null,this.m_distCurveType),a.val<_&&(n.outPoint.assign(u),i.outPoint.assign(l),a.val,0===_)))return _}}return _===this.m_maxDistance?Number.POSITIVE_INFINITY:_}catch(t){s.error=t,s.hasError=!0}finally{(0,c.c)(s)}}calculateDistanceGeodeticMultipointMultipath(t,e,n,s){const a={stack:[],error:void 0,hasError:!1};try{const m=e.getImpl().querySegmentIterator();m.stripAttributes(),this.computeEnvelopesAndBoxes(t,e);const h=this.estimateMinimumDistance(n,s);let _=h<this.m_maxDistance?h:this.m_maxDistance;const u=new o.P,l=new o.P(0,0),p=new o.P(0,0),g=new o.P(0,0),d=[0],y=H(),P=(0,c.b)(a,this.createDistanceFunctor(l,p,g),!1),x=K(),f=this.canUseSpatialTree(t,e);f&&this.buildSpatialTree(x,e);const S=t.getPointCount();for(let e=0;e<S;++e)if(u.assign(t.getXY(e)),l.assign(t.getXY(e)),this.m_bIsPannablePcs&&(0,r.D)(this.m_inputSR,[u],1,!1),y.setCoords({xmin:l.x,ymin:l.y,xmax:l.x,ymax:l.y}),!(this.m_envHelper.minDistanceGeodesic(y,this.m_boxGeomB)>_))if(P.setPointDistFrom(l),f)(0,i.g)(0);else{for(;m.nextPath();)for(;m.hasNextSegment();){const t=m.nextSegment();if(this.m_envHelper.minDistanceGeodesic(y,this.findOrComputeBoxSegment(m.getStartPointIndex(),t,this.m_segmentBoxesB))>_)continue;const e=this.calculateDistanceGeodeticPointSegment(u,l,t,d,P);if(e.second<_&&(n.outPoint.assign(l.mul(this.m_rpu)),this.updateOutputSegment(s,t,e.first),e.second,0===_))return 0}m.resetToFirstPath()}return _===this.m_maxDistance?Number.POSITIVE_INFINITY:_}catch(t){a.error=t,a.hasError=!0}finally{(0,c.c)(a)}}calculateDistanceGeodeticMultipathGeometry(t,e,n,s){switch(e.getGeometryType()){case i.G.enumPoint:return this.calculateDistanceGeodeticPointMultipath(e,t,s,n);case i.G.enumMultiPoint:return this.calculateDistanceGeodeticMultipointMultipath(e,t,s,n);case i.G.enumPolyline:case i.G.enumPolygon:case i.G.enumEnvelope:return this.calculateDistanceGeodeticMultipathMultipath(t,e,n,s);default:(0,i.a)("")}}calculateDistanceGeodeticMultipathMultipath(t,e,n,i){const s=[t],a=[e],r=this.swapGeometries(s,a),m=s[0],h=a[0];this.computeEnvelopesAndBoxes(s[0],a[0]);const _=this.estimateMinimumDistance(n,i),u=this.calculateDistanceGeodeticMultipathMultipath_(m,h,n,i,_);return r&&(i.outPoint=(0,o.c)(n.outPoint,n.outPoint=i.outPoint)),u}calculateDistanceGeodeticMultipathMultipath_(t,e,n,a,m=Number.MAX_VALUE){const h={stack:[],error:void 0,hasError:!1};try{let _=m;const u=new o.P(0,0),l=new o.P,p=new o.P(0,0),g=new o.P,d=new o.P(0,0),y=new o.P,P=new o.P,x=new o.P,f=[new o.P],S=[0],E=[0],v=H(),D=H(),G=(0,c.b)(h,this.createDistanceFunctor(d,u,p),!1),M=K(),w=this.canUseSpatialTree(t,e);w&&this.buildSpatialTree(M,e);const T=e.querySegmentIterator();T.stripAttributes();const b=new s.S,A=(0,Distance2DCalculator_CXhBP_8I.s)(t);for(let e=0;e<A.length;++e){const s=A[e];t.getSegmentBuffer(s,b,!0);const o=b.get();if(v.assign(this.findOrComputeBoxSegment(s,o,this.m_segmentBoxesA)),w)(0,i.g)(0);else{if(d.assign(o.getStartXY()),y.assign(o.getStartXY()),P.assign(o.getEndXY()),x.assign(o.getEndXY()),this.m_bIsPannablePcs&&((0,r.x)(this.m_inputSR,0,[y],1),(0,r.x)(this.m_inputSR,0,[x],1)),this.m_envHelper.minDistanceGeodesic(v,this.m_boxGeomB)>_)continue;for(;T.nextPath();){for(;T.hasNextSegment();){const t=T.nextSegment();if(u.assign(t.getStartXY()),l.assign(t.getStartXY()),p.assign(t.getEndXY()),g.assign(t.getEndXY()),o.intersect(t,f,S,E,this.m_tolerance))return this.updateOutputSegment(n,o,S[0]),this.updateOutputSegment(a,t,E[0]),0;if(this.m_bIsPannablePcs&&((0,r.x)(this.m_inputSR,0,[l],1),(0,r.x)(this.m_inputSR,0,[g],1)),D.assign(this.findOrComputeBoxPoint(T.getStartPointIndex(),l,g,this.m_segmentBoxesB)),this.m_envHelper.minDistanceGeodesic(v,D)>_)continue;G.setSegmentEndPoints(u,p),G.setPointDistFrom(y);let e=(0,r.E)(G.makeFunctor(),0,1,1e-10);if(e.second<_&&(n.outPoint.assign(y.mul(this.m_rpu)),this.updateOutputSegment(a,t,e.first),e.second,0===_))break;if(G.setPointDistFrom(x),(0,r.E)(G.makeFunctor(),0,1,1e-10),e.second<_&&(n.outPoint.assign(x.mul(this.m_rpu)),this.updateOutputSegment(a,t,e.first),e.second,0===_))break;if(G.setSegmentEndPoints(d,P),G.setPointDistFrom(l),(0,r.E)(G.makeFunctor(),0,1,1e-10),e.second<_&&(this.updateOutputSegment(n,o,e.first),a.outPoint.assign(l.mul(this.m_rpu)),e.second,0===_))break;if(G.setPointDistFrom(g),(0,r.E)(G.makeFunctor(),0,1,1e-10),e.second<_&&(this.updateOutputSegment(n,o,e.first),a.outPoint.assign(g.mul(this.m_rpu)),e.second,0===_))break}if(0===_)return 0}T.resetToFirstPath()}}return _===this.m_maxDistance?Number.POSITIVE_INFINITY:_}catch(t){h.error=t,h.hasError=!0}finally{(0,c.c)(h)}}calculateDistanceGeodeticPointSegment(t,e,n,i,s){const a=n.getStartXY(),m=n.getEndXY();return n.intersectPoint(t,i,this.m_tolerance)?(0,o.k)(i[0],0):(s.setPointDistFrom(e),s.setSegmentEndPoints(a,m),(0,r.E)(s.makeFunctor(),0,1,1e-10))}prepareGeometry(t){let e=t.clone();const n=t.getGeometryType();if(n===i.G.enumPoint||n===i.G.enumMultiPoint)return this._NormalizeAndProject(e);if(n===i.G.enumEnvelope&&this.envelopeToPolygon(e),this.m_inputSR.isPannable())return this.prepareGeometryPannable(e,4);if(2===this.m_inputSR.getCoordinateSystemType()){if((0,r.F)(e,this.m_inputSR,0,null),e.isEmpty())return e;(new OperatorShapePreservingDensify_o).execute(e,this.m_inputSR,5e4,this.m_maxDeviation/2,0,null);const t=this.m_inputSR.getSRToGCSTransform();return(new r.A).execute(e,t,this.m_progressTracker)}const s=new m.Envelope2D;e.queryLooseEnvelope(s);const a=this.m_inputSR.getPannableExtent();if(s.ymin<a.ymin||s.ymax>a.ymax){const t=new m.Envelope2D(s.xmin-1,a.ymin,s.xmax+1,a.ymax);if((new _.O).execute(e,t,this.m_inputSR,this.m_progressTracker),e.isEmpty())return e}return s.width()>2*a.width()?((0,r.G)(e,-2*a.width(),2*a.width(),this.m_inputSR,!0,0,!0,this.m_progressTracker),e):e}prepareGeometryPannable(t,e){const n=new m.Envelope2D;t.queryEnvelope(n);const i=this.m_inputSR.getPannableExtent();if(i.containsEnvelope(n))return t;const s=new o.E;i.queryIntervalX(s);const a=new o.E;return n.queryIntervalX(a),s.contains(a)?(0,r.H)(t,this.m_inputSR):(new r.A).foldInto360RangeGeodetic(t,this.m_inputSR,e)}prepareOutput(t){t.outPoint.scale(1/this.m_rpu),2===this.m_inputSR.getCoordinateSystemType()&&(0,r.D)(this.m_inputSR,[t.outPoint],1,!1)}updateOutputSegment(t,e,n){e.queryCoord2D(n,t.outPoint),this.m_bIsPannablePcs&&(0,r.x)(this.m_inputSR,0,[t.outPoint],1),t.outPoint.mulThis(this.m_rpu)}computeTolerance(t,e){t.queryEnvelope(this.m_envGeomA),e.queryEnvelope(this.m_envGeomB);const n=new m.Envelope2D(this.m_envGeomA);return n.mergeEnvelope2D(this.m_envGeomB),(0,h.a)(null,n)}envelopeToPolygon(t){const e=new s.a;return e.addEnvelope(t,!1),e}computeEnvelopesAndBoxes(t,e){t.queryEnvelope(this.m_envGeomA),e.queryEnvelope(this.m_envGeomB),this.m_boxGeomA=this.computeBoxGeometry(t,this.m_boundaryPtsA,this.m_segmentBoxesA),this.m_boxGeomB=this.computeBoxGeometry(e,this.m_boundaryPtsB,this.m_segmentBoxesB)}computeBoxGeometry(t,e,n){switch(t.getGeometryType()){case i.G.enumPoint:return this.computeBoxPoint(t,e);case i.G.enumMultiPoint:return this.computeBoxMultiPoint(t,e);case i.G.enumPolyline:case i.G.enumPolygon:return this.computeBoxMultiPath(t,e,n);default:(0,i.d)("Invalid geometry type")}}computeBoxPoint(t,e){const n=t.getXY();e.length=0,e.push(n.mul(this.m_rpu));const i=H();return i.setCoords({xmin:n.x,ymin:n.y,xmax:n.x,ymax:n.y}),i}computeBoxMultiPoint(t,e){let n=!0;for(let i=0;i<t.getPointCount();++i){const s=t.getXY(i);if(n){e.length=0;for(let t=0;t<4;++t)e.push(s.clone());!1}s.x<e[0].x&&e[0].assign(s),s.y>e[1].y&&e[1].assign(s),s.x>e[2].x&&e[2].assign(s),s.y<e[3].y&&e[3].assign(s)}for(let t=0;t<e.length;++t)e[t].mulThis(this.m_rpu);const i=H();return t.queryEnvelope(i),i}computeBoxMultiPath(t,e,n){let i=!0;const s=H();s.setEmpty();const a=t.querySegmentIterator();for(a.stripAttributes();a.nextPath();)for(;a.hasNextSegment();){const t=a.nextSegment(),o=t.getStartXY(),m=t.getEndXY();if(this.m_bIsPannablePcs&&((0,r.x)(this.m_inputSR,0,[o],1),(0,r.x)(this.m_inputSR,0,[m],1)),i){for(let t=0;t<4;++t)e.push(o.clone());!1}o.x<e[0].x&&e[0].assign(o),o.y>e[1].y&&e[1].assign(o),o.x>e[2].x&&e[2].assign(o),o.y<e[3].y&&e[3].assign(o),m.x<e[0].x&&e[0].assign(m),m.y>e[1].y&&e[1].assign(m),m.x>e[2].x&&e[2].assign(m),m.y<e[3].y&&e[3].assign(m);const h=this.findOrComputeBoxPoint(a.getStartPointIndex(),o,m,n);s.mergeEnvelope2D(h)}for(let t=0;t<e.length;++t)e[t].mulThis(this.m_rpu);return s}findOrComputeBoxSegment(t,e,n){if(!n.has(t)){let i=H();if(e.queryEnvelope(i),this.m_bIsPannablePcs){const t=o.P.construct(i.xmin,i.ymin),e=o.P.construct(i.xmax,i.ymax);(0,r.x)(this.m_inputSR,0,[t],1),(0,r.x)(this.m_inputSR,0,[e],1),this.m_envHelper.calculateBbox(t.x,t.y,e.x,e.y)}return n.set(t,i),i}return n.get(t)}findOrComputeBoxPoint(t,e,n,i){if(!i.has(t)){let s=H();return s.setCoords({xmin:e.x,ymin:e.y,xmax:n.x,ymax:n.y}),this.m_bIsPannablePcs&&this.m_envHelper.calculateBbox(s.xmin,s.ymin,s.xmax,s.ymax),i.set(t,s),s}return i.get(t)}estimateMinimumDistance(t,e){const n={stack:[],error:void 0,hasError:!1};try{const i=t=>(0,r.w)(this.m_a,this.m_eSquared,t),s=this.m_boundaryPtsA.map(i),a=this.m_boundaryPtsB.map(i);let o=Number.MAX_VALUE,m=0,_=0;for(let t=0;t<s.length;++t)for(let e=0;e<a.length;++e){const n=h.d.distance(s[t],a[e]);n<o&&(n,t,e)}t.outPoint.assign(this.m_boundaryPtsA[m]),e.outPoint.assign(this.m_boundaryPtsB[_]);const u=(0,c.b)(n,new r.P,!1);return r.z.geodeticDistance(this.m_a,this.m_eSquared,this.m_boundaryPtsA[m].x,this.m_boundaryPtsA[m].y,this.m_boundaryPtsB[_].x,this.m_boundaryPtsB[_].y,u,null,null,this.m_distCurveType),u.val}catch(t){n.error=t,n.hasError=!0}finally{(0,c.c)(n)}}swapGeometries(t,e){return(0,i.v)(t[0])>(0,i.v)(e[0])&&(e[0]=(0,o.c)(t[0],t[0]=e[0]),this.m_envGeomB=(0,o.c)(this.m_envGeomA,this.m_envGeomA=this.m_envGeomB),!0)}canUseSpatialTree(t,e){return!1}checkGeometriesIntersect(t,e,n,s){let a=t.getGeometryType(),o=e.getGeometryType();if(this.m_envGeomA.isIntersecting(this.m_envGeomB)){if(a===i.G.enumPoint&&2===e.getDimension()){const i=[0],a=[t.getXY()];if((0,r.I)(e,a,1,this.m_tolerance,i),0!==i[0])return n.outPoint.assign(a[0]),s.outPoint.assign(a[0]),!0}else if(o===i.G.enumPoint&&2===t.getDimension()){const i=[2],a=[e.getXY()];if((0,r.I)(t,a,1,this.m_tolerance,i),0!==i[0])return n.outPoint.assign(a[0]),s.outPoint.assign(a[0]),!0}if(a===i.G.enumMultiPoint&&2===e.getDimension())return this.multipointIntersectsArea(t,e,n,s);if(o===i.G.enumMultiPoint&&2===t.getDimension())return this.multipointIntersectsArea(e,t,s,n);let m,h,_=t,u=e;if(a===i.G.enumEnvelope&&(this.envelopeToPolygon(t),m,i.G.enumPolygon),o===i.G.enumEnvelope&&(this.envelopeToPolygon(e),h,i.G.enumPolygon),(0,i.h)(a)&&(0,i.h)(o)){const t=_.querySegmentIterator(),e=u.querySegmentIterator(),i=(0,Distance2DCalculator_CXhBP_8I.m)(),a=(0,Distance2DCalculator_CXhBP_8I.m)();if((0,Distance2DCalculator_CXhBP_8I.w)(_,u,t,e,i,a))return n.outPoint.assign(i.outPoint),s.outPoint.assign(i.outPoint),!0}}return!1}multipointIntersectsArea(t,e,n,i){const s=t.getPointCount();for(let a=0;a<s;++a){const s=[2],o=t.getXY(a);if((0,r.I)(e,[o],1,this.m_tolerance,s),0!==s[0])return n.outPoint.assign(o),i.outPoint.assign(o),!0}return!1}getNearestNeighbourVisitor(t,e,n,s,a,r,o){return(0,i.g)(0),{}}buildSpatialTree(t,e){(0,i.g)(0)}}class y{constructor(t,e,n,i,s=100){this.m_startPt=t.clone(),this.m_endPt=e.clone(),this.m_cE2=i,this.m_cE=Math.sqrt(this.m_cE2),this.m_c1By2e=1/(2*this.m_cE),this.m_cRpu=n.getGCS().getUnit().getUnitToBaseFactor(),this.isPcs=2===n.getCoordinateSystemType(),this.PEProjcs=n.getPECoordSys(),this.m_points=(0,o.d)(2*s,Number.NaN)}setSegmentEndPoints(t,e){this.m_startPt.assign(t),this.m_endPt.assign(e)}makeFunctor(){return t=>{const e=[0,0];e[0]=this.m_startPt.x*(1-t)+this.m_endPt.x*t,e[1]=this.m_startPt.y*(1-t)+this.m_endPt.y*t,this.isPcs&&r.K.projToGeogCenter(this.PEProjcs,1,e,0);const n=Math.sin(e[1]*this.m_cRpu);return 0===this.m_cE2?n:-Math.log((1-this.m_cE*n)/(1+this.m_cE*n))*this.m_c1By2e+n/(1-this.m_cE2*n*n)}}}function P(t,e,n,i,s){const a=function(t,e,n){const i=t.calculateLength2D(),s=(new u.O).execute(t,e,n)/25e3,a=i/t.getSegmentCount()*2;let r=Math.min(a,i/s);return 0===r&&(r=1),(0,o.k)(r,i/r)}(t,e,s);let r=x(t,a.first,n,i,s),m=1,h=0,_=0;do{if(m++,a.first*=.5,a.first<50*e.getTolerance(0))return r;a.second*=2,_=x(t,a.first,n,i,s),h=Math.abs(_-r),r=_}while(Math.abs(r)>1&&h>1e-8*Math.abs(r)&&(a.second<65e3&&m<8||m<4));return _}function x(t,e,n,i,s){const o=(new a.O).execute(t,e,0,0,s);let h;h=i?(new r.A).execute(o,i,s):o;const _=1===n.getUnit().getUnitToBaseFactor()?Math.PI/180:1,u=new m.Envelope2D;h.queryEnvelope(u);const c=new m.Envelope2D,l=new m.Envelope2D,p=new m.Envelope2D;c.setCoords({xmin:u.xmin,ymin:75*_,xmax:u.xmax,ymax:90*_}),l.setCoords({xmin:u.xmin,ymin:-60*_,xmax:u.xmax,ymax:75*_}),p.setCoords({xmin:u.xmin,ymin:-90*_,xmax:u.xmax,ymax:-60*_}),c.inflateCoords(.01*c.width(),0),l.inflateCoords(.01*l.width(),0),p.inflateCoords(.01*p.width(),0);let g=0;return g+=f(h,c,n,s),g+=f(h,l,n,s),g+=f(h,p,n,s),g}function f(t,e,n,s){const a=(new _.O).execute(t,e,n,s);if(null!==a&&!a.isEmpty()){const t=new m.Envelope2D;a.queryEnvelope(t);const{first:e,second:h}=function(t,e,n){const s=function(t,e,n){const s=t.getUnit().getUnitToBaseFactor(),a=e.getCenter();a.scale(180*s/Math.PI);const m=new o.P;m.x=0,m.y=0;let h=0;if(0===h){a.y>45?(m.y=o.o,h=0):a.y<-45?(m.y=-o.o,h=1):a.x>=45&&a.x<135?(m.x=o.o,h=2):a.x>=135||a.x<-135?(m.x=o.o,h=3):a.x<-45&&a.x>=-135?(m.x=-o.o,h=4):(m.x=0,h=5);const t=s*Math.sqrt((0,o.a)(e.xmin-e.xmax)+(0,o.a)(e.ymin-e.ymax)),n=m.clone(),i=e.getCenter();if(i.scale(s),h<2&&(n.x=i.x),o.P.distance(n,i)+.5*t>o.o)return null}const _=S[h];if(null!==_&&_.getGCS().equalHorizontal(t))return _;const u=t.getText(),c=m.x,l=m.y,p=0,g=0;let d=0,y=-1;6!==h?y=r.a9.PE_PRJ_LAMBERT_AZIMUTHAL_EQAREA:((0,i.g)(n),d=0,y=r.a9.PE_PRJ_CYLINDRICAL_EQAREA);const P=(0,r.aw)("EqualAreaPCS");let x;y===r.a9.PE_PRJ_LAMBERT_AZIMUTHAL_EQAREA?x=`PROJCS["${P}",${u},PROJECTION["Lambert_Azimuthal_Equal_Area"],PARAMETER["False_Easting",${p}],PARAMETER["False_Northing",${g}],PARAMETER["Central_Meridian",${c}],PARAMETER["Latitude_of_Origin",${l}],UNIT["Meter",1.0]]`:y===r.a9.PE_PRJ_CYLINDRICAL_EQAREA?x=`PROJCS["${P}",${u},PROJECTION["Cylindrical_Equal_Area"],PARAMETER["False_Easting",${p}],PARAMETER["False_Northing",${g}],PARAMETER["Central_Meridian",${c}],PARAMETER["Standard_Parallel_1",${d}],PARAMETER["Latitude_of_Origin",${l}],UNIT["Meter",1.0]]`:(0,i.d)("getEqualAreaPcsFixed");const f=(0,r.a)(x);return S[h]&&S[h].destroy(),S[h]=f,f}(t,e,n);if(null!==s)return(0,o.k)(s,!1);const a=t.getText(),m=t.getUnit().getUnitToBaseFactor(),h=(e.xmin+e.width()/2)*m,_=(e.ymin+e.height()/2)*m,u=0,c=0;let l=0,p=0,g=-1;e.ymin*m>=75*Math.PI/180||e.ymax*m<=-60*Math.PI/180?g=r.a9.PE_PRJ_LAMBERT_AZIMUTHAL_EQAREA:e.ymin>0||e.ymax<0?(l=(e.ymin+1/3*e.height())*m,p=(e.ymin+2/3*e.height())*m,g=r.a9.PE_PRJ_ALBERS):(l=(e.ymin+2/3*e.height())*m,g=r.a9.PE_PRJ_CYLINDRICAL_EQAREA);const d=(0,r.aw)("EqualAreaPCS");let y;return g===r.a9.PE_PRJ_LAMBERT_AZIMUTHAL_EQAREA?y=`PROJCS["${d}",${a},PROJECTION["Lambert_Azimuthal_Equal_Area"],PARAMETER["False_Easting",${u}],PARAMETER["False_Northing",${c}],PARAMETER["Central_Meridian",${h}],PARAMETER["Latitude_of_Origin",${_}],UNIT["Meter",1.0]]`:g===r.a9.PE_PRJ_ALBERS?y=`PROJCS["${d}",${a},PROJECTION["Albers"],PARAMETER["False_Easting",${u}],PARAMETER["False_Northing",${c}],PARAMETER["Central_Meridian",${h}],PARAMETER["Standard_Parallel_1",${l}],PARAMETER["Standard_Parallel_2",${p}],PARAMETER["Latitude_of_Origin",${_}],UNIT["Meter",1.0]]`:g===r.a9.PE_PRJ_CYLINDRICAL_EQAREA?y=`PROJCS["${d}",${a},PROJECTION["Cylindrical_Equal_Area"],PARAMETER["False_Easting",${u}],PARAMETER["False_Northing",${c}],PARAMETER["Central_Meridian",${h}],PARAMETER["Standard_Parallel_1",${l}],PARAMETER["Latitude_of_Origin",${_}],UNIT["Meter",1.0]]`:(0,i.d)("getEqualAreaPCSInstance"),(0,o.k)((0,r.a)(y),!0)}(n,t,!1),_=(0,r.B)(n,e,null),u=(new r.A).execute(a,_,s).calculateArea2D();return h&&e.destroy(),u}return 0}const S=[null,null,null,null,null,null,null];class E{getOperatorType(){return 10314}supportsCurves(){return!0}accelerateGeometry(t,e,n){return!1}canAccelerateGeometry(t){return!1}execute(t,e,n){if(0===e.getCoordinateSystemType()&&(0,i.a)(""),t.isEmpty()||t.getDimension()<2)return 0;if((0,i.c)(t),t.getGeometryType()===i.G.enumEnvelope){const i=new s.a;return i.addEnvelope(t,!1),this.execute(i,e,n)}let u=t;t.getDescription().getAttributeCount()>1&&(u=t.clone(),u.dropAllAttributes());const c=(new a.O).execute(u,0,e.getTolerance(0),0,n);let l=null;const p=e.getGCS();p!==e&&(l=(0,r.B)(e,p));let g=(new r.O).execute(c,e,!1,n);return g.isEmpty()?0:(g===t&&(g=t.clone()),e.isPannable()?function(t,e,n){const i=new m.Envelope2D;t.queryEnvelope(i);const a=(0,h.c)(e,i,!0).total(),u=e.getPannableExtent();u.xmin=i.xmin-10*a,u.xmax=i.xmax+10*a;const c=(new _.O).execute(t,u,e,n).getImpl().querySegmentIterator();c.stripAttributes();const l=(0,r.v)();e.querySpheroidData(l);const p=l.e2,g=0===p?2:1,d=new o.P(0,0),P=new o.P(0,0),x=new o.K(0),f=new y(d,P,e,p,100);for(;c.nextPath();)for(;c.hasNextSegment();){const t=c.nextSegment();d.assign(t.getStartXY()),P.assign(t.getEndXY()),f.setSegmentEndPoints(d,P);const e=(0,s.x)(6,0,1,1e-12,1e-15,f.makeFunctor());x.pe((P.x-d.x)*e)}const S=l.majorSemiAxis;return g*S*S*(1-p)*Math.PI*x.getResult()/e.getPannableExtent().width()}(g,e,n):P(g,e,p,l,n))}}function v(){return{m_p_PCS:new o.P,m_factor:Number.NaN,setValues:D,assign:G}}function D(t,e){this.m_factor=t,this.m_p_PCS.assign(e)}function G(t){this.m_factor=t.m_factor,this.m_p_PCS.assign(t.m_p_PCS)}class M{constructor(t,e,n,i){this.m_ptStart=new h.d,this.m_ptEnd=new h.d,this.m_ptStart.assign(e),this.m_ptEnd.assign(n),this.m_deltaX=this.m_ptEnd.x-this.m_ptStart.x,this.m_deltaY=this.m_ptEnd.y-this.m_ptStart.y,this.m_e=Math.sqrt(t),this.m_e2=t,this.m_c1MinusE2=1-t;const s=Math.sin(i);let a;a=0===this.m_e2?2*s:s*((0,o.y)(this.m_e*s)+1/(1-this.m_e2*s*s)),this.m_baseA=a}setSegmentEndPoints(t,e){this.m_ptStart.assign(t),this.m_ptEnd.assign(e),this.m_deltaX=this.m_ptEnd.x-this.m_ptStart.x,this.m_deltaY=this.m_ptEnd.y-this.m_ptStart.y}makeFunctor(){return t=>{const e=1-t,n=e*this.m_ptStart.x+t*this.m_ptEnd.x,i=e*this.m_ptStart.y+t*this.m_ptEnd.y,s=e*this.m_ptStart.z+t*this.m_ptEnd.z,a=n*n+i*i,r=s/Math.sqrt(s*s+this.m_c1MinusE2*this.m_c1MinusE2*a);let m;return m=0===this.m_e2?2*r:r*((0,o.y)(this.m_e*r)+1/(1-this.m_e2*r*r)),(this.m_deltaY*n-this.m_deltaX*i)/a*(m-this.m_baseA)}}}function w(){return{sin_phi:Number.NaN,one_p_sin_phi:Number.NaN,one_m_sin_phi:Number.NaN,one_m_e_2_sin_2_phi:Number.NaN,sin_half_phi_pf:Number.NaN,sin_half_phi_pz:Number.NaN,sin_half_asin_e_sin_phi_pf:Number.NaN,sin_half_asin_e_sin_phi_pz:Number.NaN,atanh_sin_phi:Number.NaN,atanh_esin_phi:Number.NaN,make_negative:!1,initialize:T,changeSign:b,assign:A,clone:N}}function T(t,e,n,i){const s=.5*t;this.sin_phi=Math.sin(t);const a=e*this.sin_phi,r=.5*Math.asin(a);this.one_p_sin_phi=1+this.sin_phi,this.one_m_sin_phi=1-this.sin_phi,this.one_m_e_2_sin_2_phi=(1+a)*(1-a),this.sin_half_phi_pf=Math.sin(s+n),this.sin_half_phi_pz=Math.sin(s+i),this.sin_half_asin_e_sin_phi_pf=Math.sin(r+n),this.sin_half_asin_e_sin_phi_pz=Math.sin(r+i),this.atanh_sin_phi=Math.log(this.sin_half_phi_pf/this.sin_half_phi_pz),this.atanh_esin_phi=Math.log(this.sin_half_asin_e_sin_phi_pf/this.sin_half_asin_e_sin_phi_pz)}function b(){this.sin_phi=-this.sin_phi;let t=this.one_p_sin_phi;this.one_p_sin_phi=this.one_m_sin_phi,this.one_m_sin_phi=t,t=this.sin_half_phi_pf,this.sin_half_phi_pf=this.sin_half_phi_pz,this.sin_half_phi_pz=t,t=this.sin_half_asin_e_sin_phi_pf,this.sin_half_asin_e_sin_phi_pf=this.sin_half_asin_e_sin_phi_pz,this.sin_half_asin_e_sin_phi_pz=t,this.atanh_sin_phi=-this.atanh_sin_phi,this.atanh_esin_phi=-this.atanh_esin_phi}function A(t){this.sin_phi=t.sin_phi,this.one_p_sin_phi=t.one_p_sin_phi,this.one_m_sin_phi=t.one_m_sin_phi,this.one_m_e_2_sin_2_phi=t.one_m_e_2_sin_2_phi,this.sin_half_phi_pf=t.sin_half_phi_pf,this.sin_half_phi_pz=t.sin_half_phi_pz,this.sin_half_asin_e_sin_phi_pf=t.sin_half_asin_e_sin_phi_pf,this.sin_half_asin_e_sin_phi_pz=t.sin_half_asin_e_sin_phi_pz,this.atanh_sin_phi=t.atanh_sin_phi,this.atanh_esin_phi=t.atanh_esin_phi,this.make_negative=t.make_negative}function N(){return{...this}}class C{constructor(t,e,n){this.m_transformPCS2GCS=null,this.m_scaleToRadians=new l.T,this.m_scaleToDegrees=new l.T,this.m_progressTracker=n,(0,i.g)(4!==e),this.m_curveType=e,this.m_inputSR=t,t&&0!==t.getCoordinateSystemType()||(0,i.a)(""),this.m_inputGCS=t.getGCS(),this.m_a=0,this.m_eSquared=0,this.m_b=0,this.m_rpu=0}executePolygonGeodeticArea(t){let e,n=t.clone();if(n.dropAllAttributes(),t.hasNonLinearSegments()&&(n=(new a.O).execute(n,0,this.m_inputSR.getTolerance(0),0,this.m_progressTracker)),this.m_inputSR.isPannable()){const t=new m.Envelope2D;n.queryEnvelope(t);const e=this.m_inputSR.getPannableExtent();if(!e.containsEnvelope(t)){const i=e.getCenterX()-t.getCenterX(),s=new l.T;s.setShiftCoords(i,0),n.applyTransformation(s),t.move(i,0);const a=new o.E;e.queryIntervalX(a);const m=new o.E;t.queryIntervalX(m),n=a.contains(m)?(0,r.H)(n,this.m_inputSR):(new r.A).foldInto360RangeGeodetic(n,this.m_inputSR,this.m_curveType)}}if(this.m_transformPCS2GCS?(n=(new r.O).execute(n,this.m_inputSR,!1,this.m_progressTracker),e=n.createInstance(),(0,r.N)(this.m_transformPCS2GCS,n,e,this.m_progressTracker)||(e=(new r.A).execute(n,this.m_transformPCS2GCS,this.m_progressTracker))):e=(new r.O).execute(n,this.m_inputGCS,!1,this.m_progressTracker),e.isEmpty())return 0;if(1===this.m_curveType){const t=(0,r.v)();return this.m_inputGCS.querySpheroidData(t),this.m_a=t.majorSemiAxis,this.m_eSquared=t.e2,this.loxodromeArea(e)}const i=e.getImpl();this.m_rpu=this.m_inputGCS.getUnit().getUnitToBaseFactor(),this.m_scaleToRadians.setScale(this.m_rpu),i.applyTransformation(this.m_scaleToRadians),this.m_scaleToDegrees=this.m_scaleToRadians,this.m_scaleToDegrees.invertThis();const s=(0,r.v)();if(this.m_inputGCS.querySpheroidData(s),this.m_a=s.majorSemiAxis,this.m_b=s.minorSemiAxis,this.m_eSquared=s.e2,2===this.m_curveType)return this.executeClippedPolygonGreatEllipticArea(e);{const t={stack:[],error:void 0,hasError:!1};try{const n=r.ax.unit(9101),i=this.m_inputGCS.getPECoordSys(),s=(0,c.b)(t,i.cloneAlterUnits(n),!1);let a,o,m=this.executeClippedPolygonGeodeticArea(e,s,0),h=0;do{h++,a=this.executeClippedPolygonGeodeticArea(e,s,h),o=Math.abs(a-m),m=a}while(Math.abs(a)>1&&o>1e-8*Math.abs(a)&&h<7);return a}catch(e){t.error=e,t.hasError=!0}finally{(0,c.c)(t)}}}executeClippedPolygonGeodeticArea(t,e,n){const i={stack:[],error:void 0,hasError:!1};try{const s=new m.Envelope2D;t.queryEnvelope(s);const a=(0,c.b)(i,this.getEqualAreaPCSInstance(e,s),!1),h=t.clone();(0,r.ay)(a,h);const _=50,u=h.getImpl().getAttributeStreamRef(0),l=t.getImpl().getAttributeStreamRef(0),p=(0,c.b)(i,new r.P,!1),g=(0,c.b)(i,new r.P,!1),d=40,y=[0,0],P=(0,o.n)(v,d),x=(0,o.d)(d,-1),f=v(),S=v();let E,D;const G=a;let M=h.calculateArea2D();const w=new o.K(0),T=.5*Math.PI,b=1e-10*Math.abs(M)+1e-6,A=t.getPathCount();let N,C,I,R;const q=new o.P,B=new o.P,z=new o.P,O=new o.P,L=new o.P,Y=new o.P;let F,k;for(C=t.getPathStart(0),N=0;N<A;N++,C=I)for(I=t.getPathEnd(N),u.queryPoint2D(I-1<<1,z),l.queryPoint2D(I-1<<1,q),Math.abs(q.y)>T&&(q.y=(0,o.f)(T,q.y)),R=C;R<I;R++,z.assign(O),q.assign(B)){if(u.queryPoint2D(R<<1,O),l.queryPoint2D(R<<1,B),Math.abs(B.y)>T&&(B.y=(0,o.f)(T,B.y)),F=o.P.distance(z,O),F<_||0===q.y&&0===B.y)continue;r.z.geodeticDistance(this.m_a,this.m_eSquared,q.x,q.y,B.x,B.y,p,g,null,this.m_curveType);const t=p.val,e=g.val;for(f.setValues(0,z),S.setValues(1,O),D=n,P[0].assign(S),x[0]=n,E=0;E>=0;){k=.5*(f.m_factor+S.m_factor),r.z.geodeticCoordinate(this.m_a,this.m_eSquared,q.x,q.y,t*k,e,p,g,this.m_curveType),L.x=p.val,L.y=g.val,y[0]=L.x,y[1]=L.y,r.K.geogToProj(G,1,y),Y.x=y[0],Y.y=y[1];const n=.5*-Y.offset(f.m_p_PCS,S.m_p_PCS)*o.P.distance(f.m_p_PCS,S.m_p_PCS);if(w.pe(n),Math.abs(n)>b||Math.abs(n)>0&&D>0)S.setValues(k,Y),E++,P[E].assign(S),Math.abs(n)<=b?(D--,x[E-1]=D,x[E]=D):(D=x[E-1],x[E]=D);else{if(E<=0)break;f.assign(S),E--,S.assign(P[E]),D=x[E]}}}return M+=w.getResult(),Math.abs(M)}catch(t){i.error=t,i.hasError=!0}finally{(0,c.c)(i)}}executeClippedPolygonGreatEllipticArea(t){const e=[],n=[],i=new o.P,s=new o.P,a=(0,r.w)(1,this.m_eSquared,new o.P(0,.5*Math.PI)),_=new o.K(0),u=new o.K(0),c=new o.K(0),l=new h.d,p=new h.d,g=new m.Envelope2D;t.queryLooseEnvelope(g);let d=0;g.containsCoords(g.xmin,0)||(d=Math.abs(g.ymin)<Math.abs(g.ymax)?g.ymin:g.ymax);const y=new M(this.m_eSquared,l,p,d),P=this.m_a*this.m_a,x=t.getImpl().querySegmentIterator();for(x.stripAttributes();x.nextPath();)for(;x.hasNextSegment();){const t=x.nextSegment();i.assign(t.getStartXY()),s.assign(t.getEndXY()),s.x-i.x>Math.PI?i.x+=2*Math.PI:s.x-i.x<-Math.PI&&(s.x+=2*Math.PI),this.splitSegmentCrossingItegralThreshold(t,e,n);for(let t of e)l.assign((0,r.w)(this.m_a,this.m_eSquared,t.getStartXY())),p.assign((0,r.w)(this.m_a,this.m_eSquared,t.getEndXY())),y.setSegmentEndPoints(l,p),this.adaptiveIntegrationWithRomberg(y,_);for(let t of n){let e=t.getStartXY(),n=t.getEndXY(),i=d;e.y<0&&(n=(0,o.c)(e,e=n),e.y=-e.y,n.y=-n.y,i=-i);const s=(0,r.w)(1,this.m_eSquared,e),m=(0,r.w)(1,this.m_eSquared,n),_=Math.min(e.y,n.y),l=(0,r.az)(this.m_eSquared,e.x,n.x,i,_);u.pe(l);const p=Math.abs((0,r.az)(this.m_eSquared,e.x,n.x,_,o.o)),g=new h.d;g.setSub(s,a);const y=new h.d;y.setSub(m,a);const x=new h.d;x.setCrossProductVector(g,y);let f=P*(p-.5*x.length());f=(0,o.f)(f,n.x-e.x),c.pe(f)}e.length=0,n.length=0}return c.getResult()+P*(.5*(1-this.m_eSquared)*_.getResult()+u.getResult())}getEqualAreaPCSInstance(t,e){const n=e.getCenterX();let i,s;const a=e.height();let m,h;(m=e.ymin>45*Math.PI/180||e.ymax<45*-Math.PI/180)?i=(0,o.f)(.5*Math.PI,e.getCenterY()):(i=e.getCenterY(),s=e.ymin+a*(2/3));const _=(0,r.aw)("EqualAreaPCS"),u=t.toString();return h=m?r.ax.fromString(r.a9.PE_TYPE_PROJCS,`PROJCS["${_}", ${u}, PROJECTION["Lambert_Azimuthal_Equal_Area"],PARAMETER["False_Easting",0],PARAMETER["False_Northing", 0],PARAMETER["Central_Meridian", ${n}], PARAMETER["Latitude_of_Origin", ${i}], UNIT["Meter",1.0]]`):r.ax.fromString(r.a9.PE_TYPE_PROJCS,`PROJCS["${_}", ${u}, PROJECTION["Cylindrical_Equal_Area"],PARAMETER["False_Easting", 0],PARAMETER["False_Northing", 0],PARAMETER["Central_Meridian", ${n}],PARAMETER["Standard_Parallel_1", ${s}],PARAMETER["Latitude_of_Origin", ${i}],UNIT["Meter",1.0]]`),h}splitSegmentCrossingItegralThreshold(t,e,n){const i=100,a=20,m=400,_=(0,r.w)(this.m_a,this.m_eSquared,new o.P(0,o.o)),u=(0,r.w)(this.m_a,this.m_eSquared,new o.P(0,-o.o)),c=this.splitSegmentPassingThroughPole(t);for(let t of c){const c=t.getStartXY(),l=t.getEndXY(),p=(0,r.w)(this.m_a,this.m_eSquared,c),g=(0,r.w)(this.m_a,this.m_eSquared,l),d=new o.P,y=new h.d;let P=h.d.sqrDistance(_,p),x=h.d.sqrDistance(p,g);if(P<=i){if(!(x>m)){n.push(new s.L({start:c,end:l}));continue}y.assign(g.sub(p)),y.normalizeThis(),y.assign(p.add(y.mul(a))),d.assign((0,r.y)(this.m_a,this.m_eSquared,y)),n.push(new s.L({start:c,end:d})),c.assign(d)}if(p.assign((0,r.w)(this.m_a,this.m_eSquared,c)),P=h.d.sqrDistance(_,g),x=h.d.sqrDistance(p,g),P<=i){if(!(x>m)){n.push(new s.L({start:c,end:l}));continue}y.assign(g.sub(p)),y.normalizeThis(),y.assign(g.sub(y.mul(a))),d.assign((0,r.y)(this.m_a,this.m_eSquared,y)),n.push(new s.L({start:d,end:l})),l.assign(d)}if(p.assign((0,r.w)(this.m_a,this.m_eSquared,c)),g.assign((0,r.w)(this.m_a,this.m_eSquared,l)),P=h.d.sqrDistance(u,p),x=h.d.sqrDistance(p,g),P<=i){if(!(x>m)){n.push(new s.L({start:c,end:l}));continue}y.assign(g.sub(p)),y.normalizeThis(),y.assign(p.add(y.mul(a))),d.assign((0,r.y)(this.m_a,this.m_eSquared,y)),n.push(new s.L({start:c,end:d})),c.assign(d)}if(p.assign((0,r.w)(this.m_a,this.m_eSquared,c)),g.assign((0,r.w)(this.m_a,this.m_eSquared,l)),P=h.d.sqrDistance(u,g),x=h.d.sqrDistance(p,g),P<=i){if(!(x>m)){n.push(new s.L({start:c,end:l}));continue}y.assign(g.sub(p)),y.normalizeThis(),y.assign(g.sub(y.mul(a))),d.assign((0,r.y)(this.m_a,this.m_eSquared,y)),n.push(new s.L({start:d,end:l})),l.assign(d)}e.push(new s.L({start:c,end:l}))}}splitSegmentPassingThroughPole(t){const e={stack:[],error:void 0,hasError:!1};try{const n=[],i=new h.d,a=new h.d,m=new h.d,_=new o.P,u=20,l=3.124139361,p=10,d=t.getStartXY(),y=t.getEndXY(),P=(0,c.b)(e,new r.P,!1);if(r.z.geodeticDistance(this.m_a,this.m_eSquared,d.x,d.y,y.x,y.y,P,null,null,2),Math.abs(y.x-d.x)>l&&P.val>u){const t=new g(new o.P(0,90),d.divide(this.m_rpu),y.divide(this.m_rpu),this.m_inputGCS,2,2);let e=(0,r.E)(t.makeFunctor(),0,1,1e-10);if(e.second<=p&&e.first>0&&e.first<1)return i.assign((0,r.w)(this.m_a,this.m_eSquared,d)),a.assign((0,r.w)(this.m_a,this.m_eSquared,y)),(0,o.x)(i,a,e.first,m),_.assign((0,r.y)(this.m_a,this.m_eSquared,m)),n.push(new s.L({start:d,end:_})),n.push(new s.L({start:_,end:y})),n;if(t.setPointDistFrom(new o.P(0,-90)),e=(0,r.E)(t.makeFunctor(),0,1,1e-10),e.second<=p&&e.first>0&&e.first<1)return i.assign((0,r.w)(this.m_a,this.m_eSquared,d)),a.assign((0,r.w)(this.m_a,this.m_eSquared,y)),(0,o.x)(i,a,e.first,m),_.assign((0,r.y)(this.m_a,this.m_eSquared,m)),n.push(new s.L({start:d,end:_})),n.push(new s.L({start:_,end:y})),n}return n.push(new s.L({start:d,end:y})),n}catch(t){e.error=t,e.hasError=!0}finally{(0,c.c)(e)}}adaptiveIntegrationWithRomberg(t,e){const n=t.makeFunctor();let i=0,a=1,r=n(i),o=n(a);const m=1e-17,h=1e-14;let _=(i+a)/2,u=n(_),c=Math.abs(u-r),l=Math.abs(o-u),p=0;for(;p++<32&&(c/l<.1||l/c<.1);)c<l?(e.pe((0,s.x)(5,i,_,h,m,n)),i=_,r=u):(e.pe((0,s.x)(5,_,a,h,m,n)),a=_,o=u),_=(i+a)/2,u=Math.abs(n(_)),c=Math.abs(u-r),l=Math.abs(o-u);e.pe((0,s.x)(5,i,a,h,m,n))}loxodromeAreaHemi(t,e,n,i,s){const a=n.clone(),r=s.clone();let m,h,_,u,c,l,p,g,d,y,P,x,f,S,E,v;return a.make_negative&&a.changeSign(),r.make_negative&&r.changeSign(),P=i-e,1===Math.abs(a.sin_phi)||1===Math.abs(r.sin_phi)?t.half_qp*P:a.sin_phi===r.sin_phi?(y=.5*t.one_m_e_2*a.sin_phi*(1/a.one_m_e_2_sin_2_phi+(0,o.y)(t.e*a.sin_phi))*P,y):(E=Math.log(r.sin_half_phi_pf*a.sin_half_phi_pz/(r.sin_half_phi_pz*a.sin_half_phi_pf)),v=Math.log(r.sin_half_asin_e_sin_phi_pf*a.sin_half_asin_e_sin_phi_pz/(r.sin_half_asin_e_sin_phi_pz*a.sin_half_asin_e_sin_phi_pf)),1===this.m_eSquared?(c=0,m=.5*(E+r.sin_phi/r.one_m_e_2_sin_2_phi-a.sin_phi/a.one_m_e_2_sin_2_phi),h=0):(c=-2*t.atanh_e_over_e*(Math.log(r.one_p_sin_phi/a.one_p_sin_phi)-t.e*v),m=(E-t.e*v)/t.one_m_e_2,h=(Math.log(r.one_m_e_2_sin_2_phi/a.one_m_e_2_sin_2_phi)+c/t.atanh_e_over_e)/t.one_m_e_2),_=-v*(a.atanh_esin_phi+r.atanh_esin_phi),u=1/a.one_m_e_2_sin_2_phi-1/r.one_m_e_2_sin_2_phi,l=(0,o.z)(r.one_m_sin_phi/t.one_p_e,t.e)-(0,o.z)(a.one_m_sin_phi/t.one_p_e,t.e),p=(0,o.z)(r.one_p_sin_phi/t.one_p_e,t.e)-(0,o.z)(a.one_p_sin_phi/t.one_p_e,t.e),g=(0,o.z)(a.one_m_sin_phi/-t.one_m_e,t.e)-(0,o.z)(r.one_m_sin_phi/-t.one_m_e,t.e),d=(0,o.z)(a.one_p_sin_phi/-t.one_m_e,t.e)-(0,o.z)(r.one_p_sin_phi/-t.one_m_e,t.e),y=.25/m*(h+_+u+c+.5*(l+p+g+d)),y+=t.half_qp,x=.5*t.one_m_e_2*a.sin_phi*(1/a.one_m_e_2_sin_2_phi+(0,o.y)(t.e*a.sin_phi)),f=.5*t.one_m_e_2*r.sin_phi*(1/r.one_m_e_2_sin_2_phi+(0,o.y)(t.e*r.sin_phi)),f<x&&(S=x,x=f,f=S),y<x&&(y=x),y>f&&(y=f),y*=P,y)}loxodromeArea(t){const e=Math.PI/180;let n=0;const i={e:Number.NaN,one_p_e:Number.NaN,one_m_e:Number.NaN,one_m_e_2:Number.NaN,atanh_e_over_e:Number.NaN,half_qp:Number.NaN,f:Number.NaN,z:Number.NaN},s=w(),a=w();i.e=Math.sqrt(this.m_eSquared),i.one_p_e=1+i.e,i.one_m_e=1-i.e,i.one_m_e_2=1-this.m_eSquared,i.atanh_e_over_e=(0,o.y)(i.e),this.m_eSquared>=1?i.half_qp=1:i.half_qp=.5*(1+i.atanh_e_over_e*i.one_m_e_2),i.f=.25*Math.PI,i.z=.75*Math.PI,a.initialize(0,i.e,i.f,i.z);const r=t.getPathCount(),m=new o.P,h=new o.P,_=t.getImpl().getAttributeStreamRef(0);for(let o=0;o<r;o++){const r=t.getPathStart(o),u=t.getPathEnd(o);if(!(u-r<=1)){_.queryPoint2D(2*(u-1),m);for(let t=r;t<u;t++){_.queryPoint2D(2*t,h);const o=m.y*e,u=h.y*e;if(t===r?(s.initialize(o,i.e,i.f,i.z),s.make_negative=!1):s.assign(a),a.initialize(u,i.e,i.f,i.z),a.make_negative=!1,m.y*h.y<0){if(m.y>=90&&h.y<=-90||h.y>=90&&m.y<=-90)return Number.NaN;const t=w();t.initialize(0,i.e,i.f,i.z),t.make_negative=!1;const r=s.atanh_sin_phi-i.e*s.atanh_esin_phi,_=a.atanh_sin_phi-i.e*a.atanh_esin_phi,u=(_*m.x-r*h.x)/(_-r);o<0?(s.make_negative=!0,n-=this.loxodromeAreaHemi(i,m.x*e,s,u*e,t),s.make_negative=!1,n+=this.loxodromeAreaHemi(i,u*e,t,h.x*e,a)):(n+=this.loxodromeAreaHemi(i,m.x*e,s,u*e,t),a.make_negative=!0,n-=this.loxodromeAreaHemi(i,u*e,t,h.x*e,a),a.make_negative=!1)}else m.y>=0?n+=this.loxodromeAreaHemi(i,m.x*e,s,h.x*e,a):(s.make_negative=!0,a.make_negative=!0,n-=this.loxodromeAreaHemi(i,m.x*e,s,h.x*e,a),s.make_negative=!1,a.make_negative=!1);m.assign(h)}}}return this.m_a*n*this.m_a}calculate(t){if(t.isEmpty()||t.getDimension()<2)return 0;if(t.getGeometryType()===i.G.enumEnvelope){const e=new s.a;return e.addEnvelope(t,!1),this.calculate(e)}return this.m_inputSR!==this.m_inputGCS&&null===this.m_transformPCS2GCS&&(this.m_transformPCS2GCS=(0,r.B)(this.m_inputSR,this.m_inputGCS,null)),this.executePolygonGeodeticArea(t)}}class I{getOperatorType(){return 10311}supportsCurves(){return!0}accelerateGeometry(t,e,n){return!1}canAccelerateGeometry(t){return!1}execute(t,e,n,s){return(0,i.c)(t),4===n?(new E).execute(t,e,s):new C(e,n,s).calculate(t)}}},33035:function(t,e,n){n.r(e),n.d(e,{OperatorGeodeticDensifyByLength:function(){return r},OperatorGeodeticDensifyCursor:function(){return o}});var i=n(81066),s=n(10057),a=n(65513);class r{getOperatorType(){return 10310}supportsCurves(){return!0}accelerateGeometry(t,e,n){return!1}canAccelerateGeometry(t){return!1}executeMany(t,e,n,i,s){return new o(t,n,i,e,-1,-1,s)}execute(t,e,n,a,r){const o=new i.S([t]),m=this.executeMany(o,e,n,a,r).next();return m||(0,s.d)("null output"),m}}class o extends i.G{constructor(t,e,n,i,a,r,o){super(),this.m_progressTracker=o,r>0&&(0,s.t)(""),4!==n&&a>0&&(0,s.t)(""),e||(0,s.a)(""),0===e.getCoordinateSystemType()&&(0,s.a)(""),i>0||a>0||(0,s.a)(""),this.m_index=-1,this.m_inputGeoms=t,this.m_spatialReference=e,this.m_curveType=n,this.m_maxLengthMeters=i,this.m_maxDeviationMeters=a,this.m_maxAngle=r}next(){{let t;for(;t=this.m_inputGeoms.next();)return(0,s.c)(t),this.m_index=this.m_inputGeoms.getGeometryID(),this.geodeticDensify(t);return null}}getGeometryID(){return this.m_index}tock(){return!0}getRank(){return 1}geodeticDensify(t){return(0,a.L)(t,this.m_spatialReference,this.m_curveType,this.m_maxLengthMeters,this.m_maxDeviationMeters,this.m_progressTracker)}}},83264:function(t,e,n){n.d(e,{O:function(){return g}});var i=n(10057),s=n(65513),a=n(11894),r=n(9519),o=n(60988),m=n(64699),h=n(95016),_=n(12069);function u(){return{m_pGcs:new r.P,m_xyz:new o.d,m_factor:Number.NaN,m_geoLength:Number.NaN,setValues:c,setLength:l,assign:p}}function c(t,e,n,i){this.m_factor=t,this.m_pGcs.assign(e),this.m_xyz.assign(i),this.m_geoLength=n}function l(t){this.m_geoLength=t}function p(t){this.m_pGcs.assign(t.m_pGcs),this.m_xyz.assign(t.m_xyz),this.m_factor=t.m_factor,this.m_geoLength=t.m_geoLength}class g{getOperatorType(){return 10315}supportsCurves(){return!0}accelerateGeometry(t,e,n){return!1}canAccelerateGeometry(t){return!1}_ExecuteShapePreservingLength(t,e,n,i,a){if(t.hasNonLinearSegments()&&(t=(new h.O).execute(t,0,e.getTolerance(0),0,a)),e.isPannable()){let i=90,r=-90;if(1===n.getUnit().getUnitToBaseFactor()&&(i*=Math.PI/180,r*=Math.PI/180),2===e.getCoordinateSystemType()){let t=null;const n=[0,0,0,0];t=e.getPECoordSys(),n[0]=0,n[1]=i,n[2]=0,n[3]=r,s.K.geogToProj(t,2,n),i=n[1],r=n[3]}const o=new m.Envelope2D;t.queryEnvelope(o),o.ymin=r,o.ymax=i,t=(new _.O).execute(t,o,e,a)}else{const n=e.getPCSHorizon();if((t=(new s.g).execute(t,n,e,a))===n){const e=t.clone();t=e}}return t.isEmpty()?0:this._ExecuteIterativeApproach(t,e,n,i,1,a)}_ExecuteIterativeApproach(t,e,n,a,m,h){const _=(0,s.v)();n.querySpheroidData(_);const c=_.majorSemiAxis,l=_.e2,p=n.getUnit().getUnitToBaseFactor(),g=(0,r.n)(u,40),P=(0,r.d)(40,Number.NaN),x=u(),f=u();let S;const E=[0,0,0,0],v=e.getPECoordSys(),D=new r.P,G=new r.P,M=new r.P,w=new r.P,T=new r.P;let b=0;const A=t.querySegmentIterator();for(;A.nextPath();)for(;A.hasNextSegment();){const t=A.nextSegment();D.assign(t.getStartXY()),G.assign(t.getEndXY()),2===e.getCoordinateSystemType()?(E[0]=D.x,E[1]=D.y,E[2]=G.x,E[3]=G.y,s.K.projToGeog(v,2,E),M.x=E[0]*p,M.y=E[1]*p,w.x=E[2]*p,w.y=E[3]*p):(M.setCoordsPoint2D(D),w.setCoordsPoint2D(G),M.scale(p),w.scale(p));const n=new o.d,a=new o.d;d(c,l,M,n),d(c,l,w,a);let r=y(c,n,a);x.setValues(0,M,Number.NaN,n),f.setValues(1,w,r,a),S=m,g[0].assign(f),P[0]=m;let h=0;for(;;){h>128&&(0,i.d)("iterations exceeded");const n=.5*(x.m_factor+f.m_factor),a=t.getCoord2D(n);2===e.getCoordinateSystemType()?(E[0]=a.x,E[1]=a.y,s.K.projToGeog(v,1,E),T.x=E[0]*p,T.y=E[1]*p):(T.setCoordsPoint2D(a),T.scale(p)),M.setCoordsPoint2D(x.m_pGcs),w.setCoordsPoint2D(f.m_pGcs);const _=new o.d;d(c,l,T,_);const u=y(c,x.m_xyz,_),D=y(c,f.m_xyz,_);r=f.m_geoLength,Number.isNaN(r)&&(r=y(c,x.m_xyz,f.m_xyz));const G=u+D,A=S===m&&G>=20&&Math.abs(G-r)>1e-8*(r+G);if(h+2<40&&(A||Math.abs(G-r)>0&&S>0))f.setLength(D),g[h].assign(f),f.setValues(n,T,u,_),g[++h].assign(f),A?(S=m,P[h]=m):(S--,P[h-1]=S,P[h]=S);else{if(b+=G,0===h)break;x.assign(f),f.assign(g[--h]),S=P[h]}}}return b}execute(t,e,n){if(e&&0!==e.getCoordinateSystemType()||(0,i.a)(""),t.isEmpty()||t.getDimension()<1)return 0;let r=null;const o=e.getGCS();o!==e&&(r=(0,s.B)(e,o,null));const m=t.getGeometryType();if(m===i.G.enumEnvelope){const i=new a.a;return i.addEnvelope(t,!1),this._ExecuteShapePreservingLength(i,e,o,r,n)}if((0,i.f)(m)){const i=new a.P;return i.addSegment(t,!0),this._ExecuteShapePreservingLength(i,e,o,r,n)}return this._ExecuteShapePreservingLength(t,e,o,r,n)}}function d(t,e,n,i){i.assign((0,s.w)(t,e,n))}function y(t,e,n){const i=t,s=new o.d;s.setSub(e,n);const a=s.length();return 2*i*Math.asin(a/(2*i))}},81066:function(t,e,n){n.d(e,{G:function(){return i},S:function(){return s}});class i{*[Symbol.iterator](){let t=this.next();for(;t;)yield t,t=this.next()}}class s extends i{constructor(t){super(),this.m_iGeom=-1,this.m_aGeoms=t?t.slice():[]}next(){if(this.m_iGeom<this.m_aGeoms.length-1){const t=this.m_aGeoms[++this.m_iGeom];return this.m_aGeoms[this.m_iGeom]=null,t}return null}tock(){return!1}getGeometryID(){return this.m_iGeom}getRank(){return 1}}}}]);